'use strict';

// clear array
Array.prototype.clear = function () {
    while (this.length) {
        this.pop();
    }
};

// check whether an object is empty
function isEmpty(obj) {
    return !Object.keys(obj).length > 0;
}

function Metro(canvas, cursorCanvas, data) {

    /*=====================================================================================================
                                             Constructors
    ======================================================================================================*/
    // elevation layer
    const elevation = (site_index) => {
        let value = state.graphics.sites[site_index]['elevation'];
        let grayScale = ((1 - value) * 255).toFixed(1);

        if (value <= state.waterline) {
            // set color for river in [elevation] mode
            return [51, 102, 153]; // lightBlue
        }

        return [grayScale, grayScale, grayScale];
    };

    // affluence layer
    const affluence = (site_index) => {
        let value = state.graphics.sites[site_index]['affluence'];
        let grayScale = ((1 - value) * 255).toFixed(1);

        return [grayScale, grayScale, grayScale];
    };

    // desirability layer
    const desirability = (site_index) => {
        let site = state.graphics.sites[site_index];
        let value = (site['elevation'] + site['affluence']) / 2;
        if (site['elevation'] <= state.waterline) value = 0;
        let grayScale = ((1 - value) * 255).toFixed(1);

        return [grayScale, grayScale, grayScale];
    };

    // district layer
    const district = (site_index) => {
        let site = state.graphics.sites[site_index];

        return state.POLYGON_TYPE_COLOR[site.type] || [255, 255, 255];
    };

    // building layer
    const building = (site_index) => {
        let site = state.graphics.sites[site_index];

        return state.POLYGON_TYPE_COLOR[site.type];
    }

    var state = {
        counter: 0, // for test
        N: Number($('#input-sites').val()) || 128,
        LAYERS: new Set([elevation]),
        EDIT_MODES: new Set(),
        LAYER: 'elevation',
        radius: 128,
        increment: $('#incrementSlider').val() || .15,
        waterline: $('#waterLineSlider').val() || .15,
        pointer: null,
        topology: null,
        allEdges: new Set(),
        vertices: data ? data.vertices.map(vertex2Array) : [],
        selectedSites: [],
        isDragging: false,
        isIncreasing: true,
        isAltPressed: false,
        showStreetNames: true,
        transform: d3.zoomIdentity, // scale parameter of zoom
        canvas: canvas || d3.select("#myCanvas").node(),
        cursorCanvas: cursorCanvas || d3.select("#cursorCanvas").node(),
        width() {
            return this.canvas.width || 1190;
        },
        height() {
            return this.canvas.height || 750;
        },
        context() {
            return this.canvas.getContext("2d");
        },
        cursorContext() {
            return this.cursorCanvas.getContext("2d");
        },
        MIN_WIDTH: 0,
        MIN_HEIGHT: 0,
        ZOOM_FACTOR: { min: 1 / 2, max: 8 }, // zoom factor
        DISTRICT_TYPES: ['rich', 'medium', 'poor', 'plaza', 'empty', 'water', 'farm', 'park', 'castle', 'harbor', 'military', 'religious', 'university'],
        COLOR: [{ R: 255, G: 0, B: 0 }, { R: 0, G: 255, B: 0 }, { R: 0, G: 0, B: 255 }],
        RANDOM_COLOR: d3.scaleOrdinal().range(d3.schemeCategory20), // random color
        POLYGON_TYPE_COLOR: {
            'rich': [152, 134, 148], // purple
            'medium': [161, 147, 127], // rice
            'poor': [103, 99, 92], // grey
            'plaza': [242, 233, 58], // yellow
            'farm': [253, 242, 205], // light yellow [253, 242, 205]
            'empty': [203, 197, 185], // light yellow #cbc5b9
            'water': [51, 102, 153], // light blue
            'park': [3, 165, 44], // light green
            'castle': [255, 255, 255], // white
            'harbor': [117, 123, 124], // light blue
            'military': [75, 83, 32], // army green
            'religious': [255, 255, 255], // white
            'university': [140, 20, 60], // red
        },
        STREET_NAMES: ["10th Street", "11th Street", "12th Street", "12th Street East", "13th Street", "14th Street", "1st Avenue", "1st Street", "2nd Avenue", "2nd Street", "2nd Street East", "2nd Street North", "2nd Street West", "3rd Avenue", "3rd Street", "3rd Street East", "3rd Street North", "3rd Street West", "4th Avenue", "4th Street", "4th Street North", "4th Street South", "4th Street West", "5th Avenue", "5th Street", "5th Street East", "5th Street North", "5th Street South", "5th Street West", "6th Avenue", "6th Street", "6th Street North", "6th Street West", "7th Avenue", "7th Street", "8th Avenue", "8th Street", "8th Street South", "8th Street West", "9th Street", "9th Street West", "Academy Street", "Adams Avenue", "Adams Street", "Amherst Street", "Andover Court", "Ann Street", "Arch Street", "Arlington Avenue", "Ashley Court", "Aspen Court", "Aspen Drive", "Atlantic Avenue", "Augusta Drive", "B Street", "Bank Street", "Bay Street", "Bayberry Drive", "Beech Street", "Beechwood Drive", "Belmont Avenue", "Berkshire Drive", "Brandywine Drive", "Briarwood Court", "Briarwood Drive", "Bridge Street", "Bridle Court", "Bridle Lane", "Broad Street", "Broad Street West", "Broadway", "Brook Lane", "Brookside Drive", "Brown Street", "Buckingham Drive", "Buttonwood Drive", "Cambridge Court", "Cambridge Drive", "Cambridge Road", "Canal Street", "Canterbury Court", "Canterbury Drive", "Canterbury Road", "Cardinal Drive", "Carriage Drive", "Catherine Street", "Cedar Avenue", "Cedar Court", "Cedar Lane", "Cedar Street", "Cemetery Road", "Center Street", "Central Avenue", "Chapel Street", "Charles Street", "Cherry Lane", "Cherry Street", "Chestnut Avenue", "Chestnut Street", "Church Road", "Church Street", "Church Street North", "Church Street South", "Circle Drive", "Clark Street", "Clay Street", "Cleveland Avenue", "Cleveland Street", "Clinton Street", "Cobblestone Court", "College Avenue", "College Street", "Colonial Avenue", "Colonial Drive", "Columbia Street", "Cooper Street", "Cottage Street", "Country Club Drive", "Country Club Road", "Country Lane", "Court Street", "Creek Road", "Creekside Drive", "Crescent Street", "Cross Street", "Cypress Court", "Deerfield Drive", "Delaware Avenue", "Depot Street", "Devon Court", "Devon Road", "Devonshire Drive", "Division Street", "Dogwood Drive", "Dogwood Lane", "Durham Court", "Durham Road", "Eagle Road", "Eagle Street", "East Avenue", "East Street", "Edgewood Drive", "Edgewood Road", "Elizabeth Street", "Elm Avenue", "Elm Street", "Elmwood Avenue", "Essex Court", "Euclid Avenue", "Evergreen Drive", "Evergreen Lane", "Fairview Avenue", "Fairview Road", "Fairway Drive", "Fawn Court", "Fawn Lane", "Fieldstone Drive", "Forest Avenue", "Forest Drive", "Forest Street", "Franklin Avenue", "Franklin Court", "Franklin Street", "Front Street", "Front Street North", "Front Street South", "Fulton Street", "Garden Street", "Garfield Avenue", "George Street", "Glenwood Avenue", "Glenwood Drive", "Grand Avenue", "Grant Avenue", "Grant Street", "Green Street", "Grove Avenue", "Grove Street", "Hamilton Road", "Hamilton Street", "Hanover Court", "Harrison Avenue", "Harrison Street", "Hartford Road", "Hawthorne Avenue", "Hawthorne Lane", "Heather Court", "Heather Lane", "Henry Street", "Heritage Drive", "Hickory Lane", "Hickory Street", "High Street", "Highland Avenue", "Highland Drive", "Hill Street", "Hillcrest Avenue", "Hillcrest Drive", "Hillside Avenue", "Hillside Drive", "Hilltop Road", "Holly Court", "Holly Drive", "Homestead Drive", "Howard Street", "Hudson Street", "Inverness Drive", "Ivy Court", "Ivy Lane", "Jackson Avenue", "Jackson Street", "James Street", "Jefferson Avenue", "Jefferson Court", "Jefferson Street", "John Street", "Jones Street", "King Street", "Lafayette Avenue", "Lafayette Street", "Lake Avenue", "Lake Street", "Lakeview Drive", "Lantern Lane", "Laurel Drive", "Laurel Lane", "Laurel Street", "Lawrence Street", "Lexington Court", "Lexington Drive", "Liberty Street", "Lilac Lane", "Lincoln Avenue", "Lincoln Street", "Linda Lane", "Linden Avenue", "Linden Street", "Locust Lane", "Locust Street", "Madison Avenue", "Madison Court", "Madison Street", "Magnolia Avenue", "Magnolia Court", "Magnolia Drive", "Maiden Lane", "Main Street", "Main Street East", "Main Street North", "Main Street South", "Main Street West", "Manor Drive", "Maple Avenue", "Maple Lane", "Maple Street", "Market Street", "Marshall Street", "Meadow Lane", "Meadow Street", "Mechanic Street", "Mill Road", "Mill Street", "Monroe Drive", "Monroe Street", "Morris Street", "Mulberry Court", "Mulberry Lane", "Mulberry Street", "Myrtle Avenue", "Myrtle Street", "New Street", "North Avenue", "North Street", "Oak Avenue", "Oak Lane", "Oak Street", "Old York Road", "Olive Street", "Orange Street", "Orchard Avenue", "Orchard Lane", "Orchard Street", "Overlook Circle", "Oxford Court", "Oxford Road", "Park Avenue", "Park Drive", "Park Place", "Park Street", "Parker Street", "Pearl Street", "Penn Street", "Pennsylvania Avenue", "Pheasant Run", "Pin Oak Drive", "Pine Street", "Pleasant Street", "Poplar Street", "Primrose Lane", "Prospect Avenue", "Prospect Street", "Queen Street", "Race Street", "Railroad Avenue", "Railroad Street", "Redwood Drive", "Ridge Avenue", "Ridge Road", "Ridge Street", "River Road", "River Street", "Riverside Drive", "Roberts Road", "Roosevelt Avenue", "Rose Street", "Rosewood Drive", "Route 1", "Route 10", "Route 100", "Route 11", "Route 17", "Route 2", "Route 20", "Route 202", "Route 27", "Route 29", "Route 30", "Route 32", "Route 4", "Route 41", "Route 44", "Route 5", "Route 6", "Route 64", "Route 7", "Route 70", "Route 9", "School Street", "Schoolhouse Lane", "Shady Lane", "Sheffield Drive", "Sherman Street", "Sherwood Drive", "Smith Street", "Somerset Drive", "South Street", "Spring Street", "Spruce Avenue", "Spruce Street", "State Street", "State Street East", "Strawberry Lane", "Street Road", "Summer Street", "Summit Avenue", "Summit Street", "Sunset Avenue", "Sunset Drive", "Surrey Lane", "Sycamore Drive", "Sycamore Lane", "Sycamore Street", "Tanglewood Drive", "Taylor Street", "Union Street", "Valley Drive", "Valley Road", "Valley View Drive", "Valley View Road", "Victoria Court", "Vine Street", "Virginia Avenue", "Virginia Street", "Wall Street", "Walnut Avenue", "Walnut Street", "Warren Avenue", "Warren Street", "Washington Avenue", "Washington Street", "Water Street", "West Avenue", "West Street", "Westminster Drive", "White Street", "William Street", "Williams Street", "Willow Avenue", "Willow Drive", "Willow Lane", "Willow Street", "Winding Way", "Windsor Court", "Windsor Drive", "Wood Street", "Woodland Avenue", "Woodland Drive", "Woodland Road", "York Road", "York Street"],
    };
    state.graphics = new Graphics(data);

    (function () {
        setWallTopology();
        state.context().save();
        state.context().fillStyle = 'rgb(203, 197, 185)';
        state.context().fillRect(0, 0, state.width(), state.height());
        state.context().restore();
        render();
    })();

    // initialize mouse event
    d3.select(state.cursorCanvas)
        .call(d3.drag()
            .container(state.cursorCanvas)
            .subject(dragsubject)
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended))
        .on("wheel", onScroll)
        .on("mousemove", onMouseMove)
        .on("contextmenu", d3.contextMenu(menu))
        .call(d3.zoom().scaleExtent([state.ZOOM_FACTOR.min, state.ZOOM_FACTOR.max]).on("zoom", zoomed));

    // initialize key event
    d3.select("body")
        .on("keyup", onKeyUp)
        .on("keydown", onKeyDown);

    /*=====================================================================================================
                                             Main Functions
    ======================================================================================================*/

    function Graphics(graphics) {
        const MAX_WIDTH = state.width() - state.MIN_WIDTH;
        const MAX_HEIGHT = state.height() - state.MIN_HEIGHT;

        this.currentCastle = graphics ? graphics.currentCastle : null;
        this.sites = graphics ? graphics.sites.map(site2Array) : d3.range(state.N).map(() => [Math.random() * (MAX_WIDTH - state.MIN_WIDTH) + state.MIN_WIDTH, Math.random() * (MAX_HEIGHT - state.MIN_HEIGHT) + state.MIN_HEIGHT, 0]);
        this.voronoi = d3.voronoi().extent([[state.MIN_WIDTH, state.MIN_HEIGHT], [MAX_WIDTH, MAX_HEIGHT]]);
        this.diagram = this.voronoi(this.sites);

        // relax sites in using Lloyd's algorithm, delete duplicated data, and reassign sites' attributes
        if (!graphics) {
            for (let n = 0; n < 5; n++) {
                this.sites = relaxAndReassignSites(this.diagram);
                this.diagram = this.voronoi(this.sites);
            }
        }

        this.edges = graphics ? graphics.edges.map(edge2Array) : this.diagram.edges.map(makeEdge);
        this.edges.forEach((e, i) => {
            if (!e) delete this.edges[i];
        });
        this.links = graphics ? graphics.links.map(link2Array) : this.diagram.links();
        this.triangles = graphics ? graphics.triangles.map(t => t.map(site2Array)) : this.diagram.triangles();
        this.polygons = graphics ? graphics.polygons.map(polygon2Array) : makePolygons(this.sites, this.diagram);
        this.vertices = state.vertices;
    }

    // convert stored polygon JSON to d3 object
    function polygon2Array(json) {
        let poly = JSON.parse(json);

        // convert polygon.center
        if (poly.hasOwnProperty('center') && !isEmpty(poly.center)) {
            if (poly.center.hasOwnProperty('clear')) delete poly.center['clear'];
            if (poly.center.hasOwnProperty('length')) delete poly.center['length'];

            poly.center = [poly.center[0], poly.center[1]];
        }

        // convert polygon.vertices
        if (poly.hasOwnProperty('vertices') && !isEmpty(poly.vertices)) {
            if (poly.vertices.hasOwnProperty('clear')) delete poly.vertices['clear'];
            if (poly.vertices.hasOwnProperty('length')) delete poly.vertices['length'];
            let object = poly.vertices, array = [];

            for (let property in object) {
                if (object.hasOwnProperty(property)) {
                    if (property !== 'length') {
                        array.push(Number(object[property]));
                    }
                }
            }
            poly.vertices = array;
        }

        // convert polygon.edges
        if (poly.hasOwnProperty('edges') && !isEmpty(poly.edges)) {
            if (poly.edges.hasOwnProperty('clear')) delete poly.edges['clear'];
            if (poly.edges.hasOwnProperty('length')) delete poly.edges['length'];
            let object = poly.edges, array = [];

            for (let property in object) {
                if (object.hasOwnProperty(property)) {
                    if (property !== 'length') {
                        array.push(Number(object[property]));
                    }
                }
            }
            poly.edges = array;
        }

        // convert polygon.cutLines
        if (poly.hasOwnProperty('cutLines') && !isEmpty(poly.cutLines)) {
            if (poly.cutLines.hasOwnProperty('clear')) delete poly.cutLines['clear'];
            if (poly.cutLines.hasOwnProperty('length')) delete poly.cutLines['length'];
            let object = poly.cutLines, array = [];

            for (let property in object) {
                if (object.hasOwnProperty(property)) {
                    if (property !== 'length') {
                        let start = [object[property][0][0], object[property][0][1]];
                        let end = [object[property][1][0], object[property][1][1]];
                        let streetName = object[property][2];
                        array.push([start, end, streetName]);
                    }
                }
            }
            poly.cutLines = array;
        }

        // convert polygon.subPolygons
        if (poly.hasOwnProperty('subPolygons') && !isEmpty(poly.subPolygons)) {
            if (poly.subPolygons.hasOwnProperty('clear')) delete poly.subPolygons['clear'];
            if (poly.subPolygons.hasOwnProperty('length')) delete poly.subPolygons['length'];

            let object = poly.subPolygons, array = [];

            // Level 1: { 0: {asd}, 1: {asd}, 2: {asd} ... n: {asd} }
            for (let property in object) {
                let subArray = [];

                // Level 2: { 0: {asd}, 1: {asd}, 2: {asd} ... n: {asd} }
                for (let subProperty in object[property]) {
                    if (object[property].hasOwnProperty('length')) delete object[property]['length'];

                    if (subProperty !== 'length' && subProperty !== 'center' && subProperty !== 'color' && subProperty !== 'rotation' && subProperty !== 'size' && subProperty !== 'type' && subProperty !== 'bounds' && subProperty !== 'area' && subProperty !== 'buildings') {
                        if (object[property][subProperty][0] && object[property][subProperty][1]) {
                            subArray.push([object[property][subProperty][0], object[property][subProperty][1]]);
                        }
                    } else {
                        if (subProperty === 'center') {
                            subArray.center = [object[property]['center'][0], object[property]['center'][1]];
                        } else if (subProperty === 'color') {
                            subArray.color = [object[property]['color'][0], object[property]['color'][1], object[property]['color'][2]];
                        } else if (subProperty === 'rotation') {
                            subArray.rotation = object[property]['rotation'];
                        } else if (subProperty === 'size') {
                            subArray.size = object[property]['size'];
                        } else if (subProperty === 'type') {
                            subArray.type = object[property]['type'];
                        } else if (subProperty === 'bounds') {
                            subArray.bounds = object[property]['bounds'];
                        } else if (subProperty === 'area') {
                            subArray.area = object[property]['area'];
                        } else if (subProperty === 'buildings') {
                            let buildingObject = object[property]['buildings'], buildingsArray = [];
                            if (buildingObject.hasOwnProperty('clear')) delete buildingObject['clear'];
                            if (buildingObject.hasOwnProperty('length')) delete buildingObject['length'];

                            // Building Layer Level 1
                            for (let buildingProperty in buildingObject) {
                                let subBuildingsArray = []; // one building

                                // Building Layer Level 2
                                for (let subBuildingProperty in buildingObject[buildingProperty]) {
                                    if (buildingObject[buildingProperty].hasOwnProperty('clear')) delete buildingObject[buildingProperty]['clear'];
                                    if (buildingObject[buildingProperty].hasOwnProperty('length')) delete buildingObject[buildingProperty]['length'];

                                    if (subBuildingProperty !== 'length' && subBuildingProperty !== 'center' && subBuildingProperty !== 'edges' && subBuildingProperty !== 'color' && subBuildingProperty !== 'rotation' && subBuildingProperty !== 'size' && subBuildingProperty !== 'type' && subBuildingProperty !== 'bounds' && subBuildingProperty !== 'area') {
                                        if (buildingObject[buildingProperty][subBuildingProperty][0] && buildingObject[buildingProperty][subBuildingProperty][1]) {
                                            subBuildingsArray.push([buildingObject[buildingProperty][subBuildingProperty][0], buildingObject[buildingProperty][subBuildingProperty][1]]);
                                        }
                                    } else {
                                        if (subBuildingProperty === 'center') {
                                            subBuildingsArray.center = [buildingObject[buildingProperty]['center'][0], buildingObject[buildingProperty]['center'][1]];
                                        } else if (subBuildingProperty === 'color') {
                                            subBuildingsArray.color = [buildingObject[buildingProperty]['color'][0], buildingObject[buildingProperty]['color'][1], object[property]['color'][2]];
                                        } else if (subBuildingProperty === 'rotation') {
                                            subBuildingsArray.rotation = buildingObject[buildingProperty]['rotation'];
                                        } else if (subBuildingProperty === 'size') {
                                            subBuildingsArray.size = buildingObject[buildingProperty]['size'];
                                        } else if (subBuildingProperty === 'type') {
                                            subBuildingsArray.type = buildingObject[buildingProperty]['type'];
                                        } else if (subBuildingProperty === 'bounds') {
                                            subBuildingsArray.bounds = buildingObject[buildingProperty]['bounds'];
                                        } else if (subBuildingProperty === 'area') {
                                            subBuildingsArray.area = buildingObject[buildingProperty]['area'];
                                        }
                                    }
                                }
                                buildingsArray.push(subBuildingsArray);
                            }
                            subArray.buildings = buildingsArray;
                        }
                    }
                }
                array.push(subArray);
            }
            poly.subPolygons = array;
        } else {
            poly.subPolygons = [];
        }

        // convert polygon.farms
        if (poly.hasOwnProperty('farms') && !isEmpty(poly.farms)) {
            if (poly.farms.hasOwnProperty('clear')) delete poly.farms['clear'];
            if (poly.farms.hasOwnProperty('length')) delete poly.farms['length'];
            let object = poly.farms, array = [];

            // Level 1: { 0: {asd}, 1: {asd}, 2: {asd} ... n: {asd} }
            for (let property in object) {
                let subArray = [];

                // Level 2: { 0: {asd}, 1: {asd}, 2: {asd} ... n: {asd} }
                for (let subProperty in object[property]) {
                    if (object[property].hasOwnProperty('length')) delete object[property]['length'];

                    if (subProperty !== 'length' && subProperty !== 'center' && subProperty !== 'rotation' && subProperty !== 'size' && subProperty !== 'type' && subProperty !== 'bounds' && subProperty !== 'area') {
                        if (object[property][subProperty][0] && object[property][subProperty][1]) {
                            subArray.push([object[property][subProperty][0], object[property][subProperty][1]]);
                        }
                    } else {
                        if (subProperty === 'center') {
                            subArray.center = [object[property]['center'][0], object[property]['center'][1]];
                        } else if (subProperty === 'rotation') {
                            subArray.rotation = object[property]['rotation'];
                        } else if (subProperty === 'size') {
                            subArray.size = object[property]['size'];
                        } else if (subProperty === 'type') {
                            subArray.type = object[property]['type'];
                        } else if (subProperty === 'bounds') {
                            subArray.bounds = object[property]['bounds'];
                        } else if (subProperty === 'area') {
                            subArray.area = object[property]['area'];
                        }
                    }
                }
                array.push(subArray);
            }
            poly.farms = array;
        } else {
            poly.farms = [];
        }

        return poly;
    }

    // convert stored site object to d3 object
    function site2Array(s) {
        const site = [s.x, s.y];
        site.wall = s.wall;
        site.type = s.type;
        site.index = s.index;
        site.delta = s.delta;
        site.color = s.color;
        site.elevation = s.elevation;
        site.affluence = s.affluence;
        site.isBoundary = s.isBoundary;
        site.desirability = s.desirability;

        return site;
    }

    // convert Object(edge) to Array(edge)
    function edge2Array(e) {
        if (e === null || e === undefined) return;

        let edge = [];
        edge[0] = [e.startPoint.x, e.startPoint.y];
        edge[0].vertexIndex = e.startPoint.vertexIndex || null;
        edge[0].edgeIndex = e.startPoint.edgeIndex || null;
        edge[1] = [e.endPoint.x, e.endPoint.y];
        edge[1].vertexIndex = e.endPoint.vertexIndex || null;
        edge[1].edgeIndex = e.endPoint.edgeIndex || null;
        edge.left = e.left;
        if (e.hasOwnProperty('right') && e.right !== null) {
            edge.right = e.right;
        }

        return edge;
    }

    // convert Object(vertex) to Array(vertex)
    function vertex2Array(v) {
        let vertex = [v.x, v.y];
        vertex.edgeIndex = v.edgeIndex;
        vertex.vertexIndex = v.vertexIndex;

        return vertex;
    }

    // convert Object(link) to Object(link)
    function link2Array(l) {
        return {
            source: site2Array(l.source),
            target: site2Array(l.target),
        }
    }

    function getCellCentroidAndReassignSites(cell, diagram, index) {
        let cx = 0, cy = 0, count = 0;

        getCellVertices(cell, diagram).forEach(v => {
            cx += v[0];
            cy += v[1];
            count++;
        });

        let site = [cx / count, cy / count];
        site.wall = 0;
        site.delta = 0;
        site.affluence = 0;
        site.index = index;
        site.type = 'empty';
        site.desirability = 0;
        site.elevation = 0.35;
        site.isBoundary = false;
        site.color = { R: Math.random() * 255, G: Math.random() * 255, B: Math.random() * 255 };

        return site;
    }

    // make edge
    function makeEdge(e) {
        let edge = [e[0], e[1]];
        edge.left = e.left.index;
        if (e.hasOwnProperty('right') && e.right !== null) {
            edge.right = e.right.index;
        }

        return edge;
    }

    // make polygons(districts)
    function makePolygons(sites, diagram) {
        return diagram.cells.map((cell, index) => {
            let polygon = {
                index: index,
                area: null,
                center: null,
                vertices: null,
                subPolygons: [],
                farms: [],
                bounds: null,
                isBoundary: false,
                edges: cell.halfedges, // an array of indexes into diagram.edges
            };

            polygon.vertices = cell.halfedges.map(i => {
                polygon.site = cell.site.index;
                diagram.edges[i].forEach(edge => {
                    if (edge.includes(Math.max(state.MIN_WIDTH, state.MIN_HEIGHT)) || edge.includes(state.width() - state.MIN_WIDTH) || edge.includes(state.height() - state.MIN_HEIGHT)) {
                        polygon.isBoundary = true;
                        sites[index].isBoundary = true;
                    }
                });

                let startVertex = cellHalfedgeStart(cell, diagram.edges[i]);
                startVertex.edgeIndex = i;
                startVertex.vertexIndex = state.vertices.length;
                state.vertices.push(startVertex);

                let endVertex = cellHalfedgeEnd(cell, diagram.edges[i]);
                if (!endVertex.hasOwnProperty('edgeIndex') || !endVertex.hasOwnProperty('vertexIndex')) {
                    endVertex.edgeIndex = i;
                    endVertex.vertexIndex = state.vertices.length;
                    state.vertices.push(endVertex);
                }

                return startVertex.vertexIndex;
            });
            let vertices = polygon.vertices.map(v => state.vertices[v]);
            let center = d3.polygonCentroid(vertices);
            polygon.center = center;
            polygon.area = Math.abs(d3.polygonArea(vertices));
            polygon.bounds = bounds(vertices, center);

            return polygon;
        });
    }

    // render
    function render() {
        state.context().save();
        state.context().clearRect(0, 0, state.width(), state.height());
        state.cursorContext().clearRect(0, 0, state.width(), state.height());
        state.context().translate(state.transform.x, state.transform.y);
        state.context().scale(state.transform.k, state.transform.k);

        /* draw districts, subPolygons, buildings */
        drawBuildings(state.context());

        // drawTriangles(state.context());
        // renderBackground(state.context());
        // drawSites(state.context(), 'black', 2);
        // drawEdges(state.context(), 'black', 2);

        if (state.LAYERS.has(building)) {
            /* draw docks */
            drawDocks(state.context(), 'rgb(233, 233, 233)', 'rgb(233, 233, 233)', 5.5); // bgColor, edgeColor, lineWidth

            /* draw streets */
            drawStreets(state.context());

            /* draw streetNames */
            if (state.showStreetNames) drawStreetNames(state.context());
        }

        /* draw walls */
        if (state.LAYERS.has(district) && state.waterline < 1) drawWalls(state.context(), 'black', 7.5);
        state.context().restore();
    }

    // assign the type for specific site via index
    function assignType4Site(index) {
        /**
         * assign type to site(polygon/district)
         *  @param waterline
         *  @param elevation
         *  @param affluence
         *  @param desirability = (`elevation` + `affluence`) / 2
         *  rich: 0.8 <= desirability <= 1
         *  medium: 0.6 < desirability < 0.8
         *  poor: waterline < desirability <= 0.6
         *  university: rich > 5 && number < 2.5 / 100 * state.N
         *  plaza/park: adjacentTypesSet.contains(`poor` && `medium` && `rich`)
         *  water: elevation <= waterline
         *  harbor: adjacentTypesSet.contains(`poor` && `water`)
         *  farm: waterline < desirability && elevation <= 0.45
         *  empty: value = 0 || (desirability <= 0.45 && desirability > state.waterline)
         *  religious: Math.random() > 0.99 && number < 2.5 / 100 * state.N
         */
        let s = state.graphics.sites[index];
        let value = (s['elevation'] + s['affluence']) / 2;
        let adjacentTypesMap = new Map();
        let adjacentTypesSet = getAdjacentTypes(s.index); // get all adjacent types -> Set<>

        if (value >= 0.8 && value <= 1) {
            s.type = 'rich';
        } else if (value < 0.8 && value > 0.6) {
            s.type = 'medium';
        } else if (value <= 0.6 && value > state.waterline) {
            s.type = 'poor';
        } else if (value === 0) {
            s.type = 'empty';
        }

        // get all adjacent types' frequencies
        [...findAdjacentSites(s.index)]
            .map(s => state.graphics.sites[s].type)
            .forEach(s => {
                if (adjacentTypesMap.has(s)) {
                    adjacentTypesMap.set(s, adjacentTypesMap.get(s) + 1);
                } else {
                    adjacentTypesMap.set(s, 1);
                }
            });

        // assign type `plaza` for district only if it is adjacent to `poor` && `medium` && `rich`
        if (adjacentTypesSet.size === 3 && adjacentTypesSet.has('poor') && adjacentTypesSet.has('medium') && adjacentTypesSet.has('rich')) {
            s.type = Math.random() > 0.5 ? 'plaza' : 'park';
        }

        // assign type `university`
        if (adjacentTypesMap.get('rich') >= 4) {
            const n = Number(getAllTypes().get('university'));
            if (!n || (n && n < 2.5 / 100 * state.N)) {
                s.type = 'university';
            }
        }

        // assign type `water`
        if (s['elevation'] <= state.waterline) {
            s.type = 'water';
            s.wall = 0;
        }

        // assign type `harbor`
        if (s.type !== 'water' && adjacentTypesSet.has('poor') && adjacentTypesSet.has('water')) {
            s.type = 'harbor';
            s.wall = 0;
        }

        // assign type `farm` and `empty`
        if (value <= 0.45 && value > state.waterline || (s.isBoundary && s.type !== 'water')) {
            s.type = Math.random() > 0.5 ? 'farm' : 'empty';
        }

        // randomly assign `religious`
        if (!s.isBoundary && s.type !== 'water') {
            if (Math.random() > 0.99) {
                const n = Number(getAllTypes().get('religious'));
                if (!n || (n && n < 2.5 / 100 * state.N)) {
                    s.type = 'religious';
                }
            }
        }

        // split polygons and assign subPolygons for polygon
        assignSubPolygons(index);
    }

    // make sub-polygons/subPolygons
    function assignSubPolygons(index) {
        const SUBPOLYGONS_NUMBER = {
            'rich': Math.round(Math.random() * 2 + 4),
            'medium': Math.round(Math.random() * 8 + 8),
            'poor': Math.round(Math.random() * 10 + 10),
            'plaza': Math.round(Math.random() * 2 + 2),
            'farm': Math.round(Math.random() * 10 + 10),
            'park': 0,
            'empty': 0,
            'water': 0,
            'castle': 0, // 1
            'harbor': Math.round(Math.random() * 4 + 8), // docks
            'military': Math.round(Math.random() * 2 + 6),
            'religious': Math.round(Math.random() * 2 + 4),
            'university': Math.round(Math.random() * 1 + 5),
        };

        let polygon = state.graphics.polygons[index],
            site = state.graphics.sites[index],
            size = SUBPOLYGONS_NUMBER[site.type],
            k = Math.random() * 0.2 + 0.4,
            vertices = convert2Vertices(polygon.vertices),
            result = splitPolygon(site.type, vertices, size, k),
            resultArr = result.subPolygons,
            cutLines = result.cutLines;

        if (resultArr !== 0 || resultArr.length) {
            resultArr.forEach(r => r.color = state.POLYGON_TYPE_COLOR[site.type]);
        }

        polygon.cutLines = cutLines;
        polygon.subPolygons = resultArr;

        // determine numbers of farms and subPolygons of type `farm`
        if (site.type === 'farm') {
            size = Math.round(Math.random() * 4 + 2);
            polygon.farms = splitPolygon(site.type, vertices, size, 0.5).subPolygons;
            // polygon.farms.forEach(sp => sp.pattern = state.context().createPattern(makeDiagonalPattern(sp), "repeat"));
            polygon.subPolygons = Math.random() > 0.8 ? [polygon.subPolygons.pop()] : [];
        } else {
            clearSubPolygons(polygon);

            if (site.type === 'plaza') {
                // determine number of subPolygons of type `plaza`
                polygon.subPolygons = Math.random() > 0.5 ? [polygon.subPolygons.pop(), polygon.subPolygons.pop()] : [polygon.subPolygons.pop()];

            } else if (site.type === 'military') {
                // determine number of subPolygons of type `military`
                result = splitPolygon(site.type, vertices, size, 0.5);
                resultArr = result.subPolygons;
                resultArr.forEach(r => r.color = state.POLYGON_TYPE_COLOR[site.type]);

                polygon.cutLines = result.cutLines;
                polygon.subPolygons = resultArr;
            }
            
            // make buildings with simulations
            polygon.subPolygons = polygon.subPolygons.map(makeBuildings);
        }
    }

    // make buildings by spliting polygon
    function makeBuildings(poly) {
        const BUILDINGS_NUMBER = {
            'rich': Math.round(Math.random() * 2 + 4),
            'medium': Math.round(Math.random() * 4 + 8),
            'poor': Math.round(Math.random() * 6 + 10),
            'plaza': Math.round(Math.random() * 2 + 2),
            'farm': 0,
            'park': 0,
            'empty': 0,
            'water': 0,
            'castle': 0, // 1
            'harbor': Math.round(Math.random() * 4 + 8), // docks
            'military': Math.round(Math.random() * 2 + 6),
            'religious': Math.round(Math.random() * 2 + 4),
            'university': Math.round(Math.random() * 1 + 5),
        },
            size = BUILDINGS_NUMBER[poly.type],
            k = Math.random() * 0.2 + 0.4,
            resultArr = splitPolygon(poly.type, poly, size, k).subPolygons;

        resultArr.forEach(r => r.color = state.POLYGON_TYPE_COLOR[poly.type]);
        poly.buildings = resultArr;
        
        return poly;
    }

    /**
     * assign type `castle`
     * @TODO find sites adjacent to s[`castle`],  s.wall = everySite.wall === 1 ? 0 : 1;
     */
    function assignCastle4Site() {
        if (!state.EDIT_MODES.has('building')) return;
        let site = null;
        let sites = state.graphics.sites.filter(s => s.type !== 'water' && s.type !== 'harbor');

        if (sites.length > 0) {
            // find max desirability
            site = sites.reduce((current, next) => current['desirability'] > next['desirability'] ? current : next);

            if (state.graphics.currentCastle && site.index !== state.graphics.currentCastle) {
                let newDesirability = state.graphics.sites[site.index]['desirability'];
                let oldDesirability = state.graphics.sites[state.graphics.currentCastle]['desirability'];
                if (newDesirability >= oldDesirability) {
                    // reassign old one
                    state.graphics.sites[state.graphics.currentCastle].wall = 0;
                    assignType4Site(state.graphics.currentCastle);
                }
            }

            // assign `castle`
            assignMilitary4Site(site.index);
            site.wall = 1;
            site.type = 'castle';
            state.graphics.currentCastle = site.index;
            assignSubPolygons(site.index);
            setWallTopology();
        }
    }

    // assign type `military`
    function assignMilitary4Site(index) {
        // reassign old military
        reassignMilitarySites();

        // get all adjacent types
        findAdjacentSites(index).forEach(i => {
            if (state.graphics.sites[i].type !== 'water') {
                state.graphics.sites[i].type = 'military';
                assignSubPolygons(i);
            }
        });
    }

    // reassign military sites
    function reassignMilitarySites() {
        state.graphics.sites
            .filter(s => s.type === 'military')
            .forEach(s => {
                let adjacentTypesSet = getAdjacentTypes(s.index); // get all adjacent districts types
                if (!adjacentTypesSet.has('castle')) {
                    assignType4Site(s.index);
                }
            });
    }

    // on changing waterline
    function onChangeWaterLine() {
        state.graphics.sites.forEach(s => assignType4Site(s.index));
        assignCastle4Site();
        render();
    }

    /*=====================================================================================================
                                             Event Functions
    ======================================================================================================*/

    function dragsubject() {
        if (state.isAltPressed) {
            return null;
        } else {
            return 0;
        }
    }

    function dragstarted() {
        if (state.EDIT_MODES.size >= 1 && !state.isAltPressed) {
            d3.contextMenu('close');
            state.isDragging = true;
        }
    }

    function dragged() {
        if (state.EDIT_MODES.size >= 1 && state.isDragging) {
            state.pointer = getMousePos(state.cursorCanvas, d3.mouse(this));

            let x = state.transform.invertX(state.pointer[0]);
            let y = state.transform.invertY(state.pointer[1]);
            state.selectedSites.clear();
            state.selectedSites = findSites(x, y, state.radius);

            if (state.isIncreasing) {
                if (state.selectedSites.length > 0) {
                    state.selectedSites.map(s => {
                        if (state.EDIT_MODES.has('district')) {
                            s['wall'] = 1;
                            if (s.type === 'water' || s.isBoundary) s['wall'] = 0;
                            setWallTopology();
                        }
                        if (state.EDIT_MODES.has('elevation')) {
                            s['elevation'] += state.increment * s.delta;
                            s['desirability'] += state.increment * s.delta;
                        }
                        if (state.EDIT_MODES.has('affluence')) {
                            s['affluence'] += state.increment * s.delta;
                            s['desirability'] += state.increment * s.delta;
                        }
                        if (state.EDIT_MODES.has('desirability') && state.EDIT_MODES.size === 1) {
                            s['elevation'] += (state.increment * s.delta) / 10;
                            s['affluence'] += (state.increment * s.delta) / 10 * 9;
                            s['desirability'] += (state.increment * s.delta) / 10 * 5;
                        }
                        if (s['elevation'] >= 1) s['elevation'] = 1;
                        if (s['affluence'] >= 1) s['affluence'] = 1;
                        if (state.EDIT_MODES.has('elevation') || state.EDIT_MODES.has('affluence')) {
                            assignType4Site(s.index);
                        }
                    });
                }
            } else {
                if (state.selectedSites.length > 0) {
                    state.selectedSites.map(s => {
                        if (state.EDIT_MODES.has('district')) {
                            s['wall'] = 0;
                            setWallTopology();
                        }
                        if (state.EDIT_MODES.has('elevation')) {
                            s['elevation'] -= state.increment * s.delta;
                            s['desirability'] -= state.increment * s.delta;
                        }
                        if (state.EDIT_MODES.has('affluence')) {
                            s['affluence'] -= state.increment * s.delta;
                            s['desirability'] -= state.increment * s.delta;
                        }
                        if (state.EDIT_MODES.has('desirability') && state.EDIT_MODES.size === 1) {
                            s['elevation'] -= (state.increment * s.delta) / 10;
                            s['affluence'] -= (state.increment * s.delta) / 10 * 9;
                            s['desirability'] -= (state.increment * s.delta) / 10 * 5;
                        }
                        if (s['elevation'] <= 0) s['elevation'] = 0;
                        if (s['affluence'] <= 0) s['affluence'] = 0;
                        if (state.EDIT_MODES.has('elevation') || state.EDIT_MODES.has('affluence')) {
                            assignType4Site(s.index);
                        }
                    });
                }
            }
            render();
            if (!(state.EDIT_MODES.has('building') && state.EDIT_MODES.size === 1)) drawCursor('red');
        }
    }

    function dragended() {
        if (state.EDIT_MODES.size >= 1 && state.isDragging) {
            // after drag end, assign type `castle`
            assignCastle4Site();
            state.isDragging = false;
            render();
        }
    }

    // mouse event
    function onMouseMove() {
        if (!state.isAltPressed && state.EDIT_MODES.size >= 1) {
            state.pointer = getMousePos(state.cursorCanvas, d3.mouse(this));

            if (!(state.EDIT_MODES.has('building') && state.EDIT_MODES.size === 1)) {
                drawCursor('red');
            }
        }
    }

    // mouse scroll event: both scroll up/down & left/right
    function onScroll() {
        if (!state.isAltPressed && state.EDIT_MODES.size >= 1) {
            state.radius -= d3.event.deltaX;
            state.radius -= d3.event.deltaY;

            if (state.radius < 15) state.radius = 15;
            if (state.radius > 700) state.radius = 700;
            if (!(state.EDIT_MODES.has('building') && state.EDIT_MODES.size === 1)) {
                drawCursor('red');
            }
        }
    }

    // set zoom arguments
    function zoomed() {
        if (state.isAltPressed) {
            state.transform = d3.event.transform;
            render();
        }
    }

    // key down event
    function onKeyDown() {
        d3.select('.d3-context-menu').remove();
        if (d3.event.altKey) state.isAltPressed = true;
    }

    // key up event
    function onKeyUp() {
        state.isAltPressed = !state.isAltPressed;
    }

    // get real mouse position in canvas
    function getMousePos(canvas, mouse) {
        let rect = canvas.getBoundingClientRect(), // abs. size of element
            scaleX = canvas.width / rect.width,    // relationship bitmap vs. element for X
            scaleY = canvas.height / rect.height,  // relationship bitmap vs. element for Y
            x = mouse[0] * scaleX,
            y = mouse[1] * scaleY;

        return [x, y];
    }

    /*=====================================================================================================
                                             Draw Functions
    ======================================================================================================*/

    // draw a line from p1[0, 1] to p2[0, 1]
    function drawLine(context, p1, p2, width, color) {
        if (state.waterline === 0 || state.waterline === 1) return;
        context.beginPath();
        context.fillStyle = color;
        context.lineWidth = width;
        context.lineCap = 'round';
        context.strokeStyle = color;
        context.moveTo(p1[0], p1[1]);
        context.lineTo(p2[0], p2[1]);
        context.fill();
        context.stroke();
    }

    // draw single polygon
    function drawPolygon(context, vertices) {
        for (let i = 0; i < vertices.length; i++) {
            let vertex = [(vertices[i][0] + .5) | 0, (vertices[i][1] + .5) | 0];
            context.moveTo(vertex[0], vertex[1]);

            for (let j = 0; j < vertices.length; j++) {
                let nextVertex = [(vertices[j][0] + .5) | 0, (vertices[j][1] + .5) | 0];
                context.lineTo(nextVertex[0], nextVertex[1]);
            }
        }
    }

    /**
     * Creates a canvas filled with a 45-degree pinstripe.
     * @returns {HTMLCanvasElement}
    */
    function makeDiagonalPattern(sub) {
        let canvasPattern = document.createElement("canvas");
        canvasPattern.width = sub.size;
        canvasPattern.height = sub.size;
        let contextPattern = canvasPattern.getContext("2d", { antialias: true, depth: false });
        contextPattern.clearRect(0, 0, canvasPattern.width, canvasPattern.height);

        // draw pattern to off-screen context
        contextPattern.beginPath();
        contextPattern.translate(sub.size / 2, sub.size / 2);
        contextPattern.rotate(sub.rotation);
        contextPattern.translate(-sub.size / 2, -sub.size / 2);
        contextPattern.moveTo(0, 0);
        contextPattern.lineTo(canvasPattern.width, canvasPattern.height);
        contextPattern.stroke();
        contextPattern.fill();

        return canvasPattern;
    }

    // draw buildings of subPolygons that of polygon
    function drawBuildings(context) {
        const k = ((state.N + 200) / 100) < state.ZOOM_FACTOR.max ? ((state.N + 200) / 100) : state.ZOOM_FACTOR.max; // zoom factor of showing buildings
        context.save();
        state.graphics.polygons.forEach(p => {
            if (!p.subPolygons || p.subPolygons === 0 || !bboxInViewport(transformBounds(p.bounds))) return;
            drawDistricts(context, p);

            p.subPolygons.forEach(subPoly => {
                if (!subPoly || subPoly === 0 || subPoly.length === 0 || !subPoly.center || !state.LAYERS.has(building) || !subPoly.type === 'farm') return;
                // draw sub polygons
                drawSubPolygons(context, subPoly);

                if (!subPoly.buildings) return;
                subPoly.buildings.forEach(d => {
                    if (!d || state.transform.k < k) return;

                    // start drawing building
                    context.beginPath();
                    context.translate(subPoly.center[0], subPoly.center[1]);
                    context.scale(0.8, 0.8);
                    context.translate(-subPoly.center[0], -subPoly.center[1]);
                    context.translate(d.center[0], d.center[1]);
                    context.scale(0.7, 0.7);
                    context.translate(-d.center[0], -d.center[1]);
                    context.lineWidth = 1.5;
                    context.strokeStyle = 'black';
                    context.fillStyle = `rgb( ${d.color[0] - 20}, ${d.color[1] - 20}, ${d.color[2] - 20} )`;
                    // context.fillStyle = state.RANDOM_COLOR(Math.random());
                    drawPolygon(context, d);
                    context.closePath();
                    context.stroke();
                    context.fill();
                    context.setTransform(1, 0, 0, 1, 0, 0);
                    context.translate(state.transform.x, state.transform.y);
                    context.scale(state.transform.k, state.transform.k);
                });
            });
        });
        context.restore();
    }

    // draw streets
    function drawStreets(context) {
        context.save();

        // draw polygon's streetName first
        state.graphics.polygons
            .filter(p => p.subPolygons && p.subPolygons.length !== 0 && state.graphics.sites[p.site].type !== 'farm')
            .forEach(p => {
                // draw outer streets (edges)
                if (!p.edges) return;
                convert2Edges(p.edges)
                    .forEach((e) => {
                        if (!e) return;
                        drawStreet(context, e, 4.5, 'rgb(203, 197, 185)');
                    });

                // draw inner streets (cutLines)
                if (!p.cutLines) return;
                p.cutLines.forEach(cut => {
                    if (!cut) return;
                    drawStreet(context, cut, 3.5, 'rgb(203, 197, 185)');
                });
            });

        context.restore();
        state.allEdges.clear(); // clear all hashes after drawing
    }

    // darw single street
    function drawStreet(context, st, width, color) {
        let hashEdge1 = hashEdge([st[0], st[1]]);
        let hashEdge2 = hashEdge([st[1], st[0]]);

        if (state.allEdges.has(hashEdge1) || state.allEdges.has(hashEdge2)) return;
        drawLine(context, st[0], st[1], width, color);
        state.allEdges.add(hashEdge1);
        state.allEdges.add(hashEdge2);
    }

    // draw all street names
    function drawStreetNames(context) {
        // set zoom factor of showing street names
        const k = ((state.N + 200) / 100) < state.ZOOM_FACTOR.max ? ((state.N + 200) / 100) : state.ZOOM_FACTOR.max;
        context.save();

        // draw polygon's streetName first
        state.graphics.polygons
            .filter(p => p.subPolygons && p.subPolygons.length !== 0 && state.graphics.sites[p.site].type !== 'farm')
            .forEach(p => {
                // draw outer street names (edges)
                if (!p.edges || p.edges.length === 0 || state.transform.k < k * .8) return;
                convert2Edges(p.edges)
                    .forEach((e, i) => {
                        if (!e) return;
                        const streetName = state.STREET_NAMES[i % state.STREET_NAMES.length];
                        drawStreetName(context, e, streetName, 3.5, 'black');
                    });

                // draw inner street names (cutLines)
                if (!p.cutLines || p.cutLines.length === 0 || state.transform.k < k * .95) return;
                p.cutLines.forEach(cut => {
                    if (!cut) return;
                    drawStreetName(context, cut, cut[2], 2.5, 'black');
                })
            });

        context.restore();
        state.allEdges.clear(); // clear all hashes after drawing
    }

    // draw single street name
    function drawStreetName(context, st, streetName, width, color) {
        let hashEdge1 = hashEdge([st[0], st[1]]);
        let hashEdge2 = hashEdge([st[1], st[0]]);

        if (state.allEdges.has(hashEdge1) || state.allEdges.has(hashEdge2)) return;
        drawName(context, st[0], st[1], streetName, width, color);
        state.allEdges.add(hashEdge1);
        state.allEdges.add(hashEdge2);
    }

    function drawName(context, p1, p2, name, width, color) {
        let
            fontWidth = context.measureText(name).width,
            midX = (p1[0] + p2[0]) / 2,
            midY = (p1[1] + p2[1]) / 2,
            x = p2[0] - p1[0],
            y = p2[1] - p1[1],
            theta = Math.atan2(y, x);

        if (y < 0 && x < 0) {
            theta = theta + Math.PI;
        } else if (y > 0 && x < 0) {
            theta = theta + Math.PI;
        }

        context.beginPath();
        context.translate(midX, midY);
        context.rotate(theta);
        context.translate(-midX, -midY);
        context.lineCap = 'round';
        context.lineWidth = width;
        context.font = `${2.5}px Arial`;
        context.fillStyle = color;
        context.fillText(`${name}`, midX - fontWidth / 2, midY + fontWidth / 25, fontWidth);
        context.fill();

        context.setTransform(1, 0, 0, 1, 0, 0);
        context.translate(state.transform.x, state.transform.y);
        context.scale(state.transform.k, state.transform.k);
    }

    // draw districts
    function drawDistricts(context, p) {
        context.save();
        let site = state.graphics.sites[p.index];
        let colors = [...state.LAYERS].map(layer => layer(p.site));
        let color = combineColors(colors);
        // start drawing polygon
        context.beginPath();
        context.fillStyle = color;
        context.strokeStyle = color;
        drawPolygon(context, convert2Vertices(p.vertices));
        context.closePath();
        context.fill();
        context.stroke();
        if (state.LAYERS.has(building) && site.type === 'farm') {
            p.farms.forEach(sub => {
                if (!sub.center) return;
                context.beginPath();
                context.translate(sub.center[0], sub.center[1]);
                context.scale(0.8, 0.8);
                context.translate(-sub.center[0], -sub.center[1]);
                let pattern = context.createPattern(makeDiagonalPattern(sub), "repeat");
                context.fillStyle = pattern;
                drawPolygon(context, sub);
                context.closePath();
                context.fill();
                context.setTransform(1, 0, 0, 1, 0, 0);
                context.translate(state.transform.x, state.transform.y);
                context.scale(state.transform.k, state.transform.k);
            });
        } else if (state.LAYERS.has(building) && site.type === 'castle') {
            context.translate(p.center[0], p.center[1]);
            context.scale(0.4, 0.4);
            context.translate(-p.center[0], -p.center[1]);
            context.fillStyle = color;
            context.lineWidth = 4;
            context.strokeStyle = 'black';
            drawPolygon(context, convert2Vertices(p.vertices));
            context.closePath();
            context.stroke();
            context.fill();
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.translate(state.transform.x, state.transform.y);
            context.scale(state.transform.k, state.transform.k);

        } else if (state.LAYERS.has(building) && site.type === 'park') {
            context.translate(p.center[0], p.center[1]);
            context.scale(0.9, 0.9);
            context.translate(-p.center[0], -p.center[1]);
            context.fillStyle = color;
            context.lineWidth = 4;
            context.strokeStyle = 'black';
            drawPolygon(context, convert2Vertices(p.vertices));
            context.closePath();
            context.stroke();
            context.fill();
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.translate(state.transform.x, state.transform.y);
            context.scale(state.transform.k, state.transform.k);
        }
        context.restore();
    }

    // draw subPolygons(splitted polygon) of polygon that has subPolygons
    function drawSubPolygons(context, subPolygon) {
        context.save();
        if (!subPolygon || subPolygon === 0 || subPolygon.length === 0 || !subPolygon.center) return;

        // start drawing subPolygon
        context.beginPath();
        context.translate(subPolygon.center[0], subPolygon.center[1]);
        context.scale(0.8, 0.8);
        context.translate(-subPolygon.center[0], -subPolygon.center[1]);
        context.lineWidth = 1.5;
        context.strokeStyle = 'black';
        context.fillStyle = `rgb( ${subPolygon.color[0]}, ${subPolygon.color[1]}, ${subPolygon.color[2]} )`;
        drawPolygon(context, subPolygon);
        context.closePath();
        context.stroke();
        context.fill();
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.translate(state.transform.x, state.transform.y);
        context.scale(state.transform.k, state.transform.k);
        context.restore();
    }

    // draw circle following mouse
    function drawCursor(color) {
        if (!state.cursorCanvas) return;

        state.cursorContext().clearRect(0, 0, state.width(), state.height());
        state.cursorContext().beginPath();

        state.cursorContext().moveTo(state.pointer[0], state.pointer[1]);
        state.cursorContext().arc(state.pointer[0], state.pointer[1], state.radius, 0, 2 * Math.PI, false);
        state.cursorContext().arc(state.pointer[0], state.pointer[1], state.radius / 2, 0, 2 * Math.PI, false);

        state.cursorContext().moveTo(state.pointer[0], state.pointer[1]);
        state.cursorContext().lineTo(state.pointer[0] - state.radius, state.pointer[1]);

        state.cursorContext().moveTo(state.pointer[0], state.pointer[1] - state.radius);
        state.cursorContext().lineTo(state.pointer[0], state.pointer[1] + state.radius);

        state.cursorContext().lineWidth = 1.5;
        state.cursorContext().strokeStyle = color;
        state.cursorContext().stroke();
    }

    // draw dock
    function drawDocks(context, bgColor, edgeColor, lineWidth) {
        if (!getAllTypes().get('harbor')) return;
        context.save();
        context.beginPath();
        state.graphics.sites
            .filter(s => s.type === 'harbor')
            .forEach(s => {
                let poly = state.graphics.polygons[s.index];

                convert2Edges(poly.edges).forEach(e => {
                    if (!e) return;
                    let left = e.hasOwnProperty('left') && e.left !== null ? state.graphics.sites[e.left] : null;
                    let right = e.hasOwnProperty('right') && e.right !== null ? state.graphics.sites[e.right] : null;
                    let waterSite = left.type === 'water' ? left : right;
                    let point = null;

                    if (waterSite.type === 'water') {
                        let midX = (e[0][0] + e[1][0]) / 2;
                        let midY = (e[0][1] + e[1][1]) / 2;
                        let d = distance(e[0], e[1]) / 2;
                        let dockDestination = getPerpendicularLineDestination(e[0][0], e[0][1], e[1][0], e[1][1], midX, midY, d);
                        let point1 = [dockDestination.x1, dockDestination.y1];
                        let point2 = [dockDestination.x2, dockDestination.y2];
                        let isPoint1 = d3.polygonContains(convert2Vertices(state.graphics.polygons[waterSite.index].vertices), point1);

                        point = isPoint1 ? point1 : point2;
                        let drawDistance = distance([midX, midY], point);
                        // condition for checking dock's length
                        if (drawDistance > 1 / state.N * 3500 || drawDistance < 1 / state.N * 1500) return;

                        context.moveTo(midX, midY);
                        context.lineTo(point[0], point[1]);
                        context.fillStyle = bgColor;
                        context.lineWidth = lineWidth;
                        context.strokeStyle = edgeColor;
                        context.fill();
                        context.stroke();
                    }
                });
            });
        context.restore();
    }

    // draw sites
    function drawSites(context, color, radius) {
        context.save();
        context.beginPath();
        state.graphics.polygons.forEach(p => {
            let site = state.graphics.sites[p.site];
            context.moveTo(site[0] + radius, site[1]);
            context.arc(site[0], site[1], radius, 0, 2 * Math.PI, false);
            context.fillStyle = color;
            context.fill();
            context.strokeStyle = color;
            context.stroke();
            // context.font = '15px Monda sans-serif';
            // context.fillText(`${site['elevation'].toFixed(1)}`, site[0] - 10, site[1] - 10);
        });
        context.restore();
    }

    // draw edges
    function drawEdges(context, color, width) {
        context.save();
        state.graphics.edges.forEach(e => {
            if (!e) return;
            drawLine(context, e[0], e[1], width, color);
        });
        context.restore();
    }

    // draw triangles
    function drawTriangles(context) {
        context.save();
        context.beginPath();

        for (let i = 0, n = state.graphics.triangles.length; i < n; ++i) {
            let triangle = state.graphics.triangles[i];
            context.moveTo(triangle[0][0], triangle[0][1]);
            context.lineTo(triangle[1][0], triangle[1][1]);
            context.lineTo(triangle[2][0], triangle[2][1]);
            context.closePath();
            context.strokeStyle = `grey`;
            context.stroke();
        }
        context.restore();
    }

    // draw multiple walls
    function drawWalls(context, color, lineWidth) {
        if (!state.topology) return;
        context.beginPath();
        context.lineWidth = lineWidth;
        context.strokeStyle = color;
        context.lineJoin = "round";
        context.fillStyle = color;
        drawWall(context, state.topology, color);
        context.stroke();
        context.fill();
    }

    // draw line of wall
    function drawWall(context, polygon) {
        polygon.coordinates.forEach(function (p) {
            p.forEach(function (ring) {
                ring.forEach(function (point, i) {
                    if (i) {
                        context.lineTo(point[0], point[1]);
                        context.moveTo(point[0], point[1]);
                        context.arc(point[0] - 2.5, point[1], 5, 0, 2 * Math.PI, false);
                    } else {
                        context.moveTo(point[0], point[1]);
                    }
                });
            });
        });
    }

    /**
     * draw terrain contour lines based on given points
     * @param point
     * @param color
     * @param width
     */
    function drawContourLines(context, point, layer, color, width) {
        context.save();
        context.translate(state.transform.x, state.transform.y);
        context.scale(state.transform.k, state.transform.k);
        state.graphics.triangles.forEach(triangle => {
            let vertices = triangle.sort((a, b) => {
                if (a[layer] < b[layer]) {
                    return -1;
                } else if (a[layer] > b[layer]) {
                    return 1;
                } else {
                    return 0;
                }
            });

            if (point >= vertices[0][layer] && point <= vertices[2][layer]) {
                let e1, e2;
                if (point >= vertices[0][layer] && point <= vertices[1][layer]) {
                    e1 = [vertices[0], vertices[1]];
                    if (point >= vertices[0][layer] && point <= vertices[2][layer]) {
                        e2 = [vertices[0], vertices[2]];
                    } else {
                        e2 = [vertices[1], vertices[2]];
                    }
                } else {
                    e1 = [vertices[1], vertices[2]];
                    if (point >= vertices[1][layer] && point <= vertices[0][layer]) {
                        e2 = [vertices[0], vertices[1]];
                    } else {
                        e2 = [vertices[0], vertices[2]];
                    }
                }

                let pt1 = pointOnEdge(e1[0], e1[1], point, layer);
                let pt2 = pointOnEdge(e2[0], e2[1], point, layer);

                drawLine(context, pt1, pt2, width, color);
            }
        });
        context.restore();
    }

    // render background
    function renderBackground(context) {
        context.save();

        state.graphics.triangles.forEach(triangle => {
            const x1 = triangle[0][0],
                y1 = triangle[0][1],
                x2 = triangle[1][0],
                y2 = triangle[1][1],
                x3 = triangle[2][0],
                y3 = triangle[2][1],
                min_width = Math.min(x1, x2, x3),
                max_width = Math.max(x1, x2, x3),
                min_height = Math.min(y1, y2, y3),
                max_height = Math.max(y1, y2, y3);

            for (let x = min_width; x < max_width; x++) {
                for (let y = min_height; y < max_height; y++) {
                    let point = [x, y];
                    if (d3.polygonContains(triangle, point)) {
                        const weight = getBarycentricValue(x1, x2, x3, y1, y2, y3, point[0], point[1]);
                        const R = (triangle[0].color.R * weight.w1) + (triangle[1].color.R * weight.w2) + (triangle[2].color.R * weight.w3);
                        const G = (triangle[0].color.G * weight.w1) + (triangle[1].color.G * weight.w2) + (triangle[2].color.G * weight.w3);
                        const B = (triangle[0].color.B * weight.w1) + (triangle[1].color.B * weight.w2) + (triangle[2].color.B * weight.w3);

                        context.beginPath();
                        context.fillStyle = `rgb(${R}, ${G}, ${B})`;
                        context.fillRect(x, y, 1, 1);
                    }
                }
            }
        });
        context.restore();
    }

    /*=====================================================================================================
                                             Additional Functions
    ======================================================================================================*/

    // get square of x
    function sqr(x) {
        return x * x;
    }

    // get distance of two vectors
    function distance(a, b) {
        return Math.sqrt(sqr(b[0] - a[0]) + sqr(b[1] - a[1]));
    }

    // get slope of line
    function slope(x1, y1, x2, y2) {
        return (y1 - y2) / (x1 - x2);
    }

    // get bounds of a specific polygon
    function bounds(polygon, center) {
        let xs = polygon.map(p => p[0]),
            ys = polygon.map(p => p[1]),
            minX = Math.min.apply(null, xs),
            maxX = Math.max.apply(null, xs),
            minY = Math.min.apply(null, ys),
            maxY = Math.max.apply(null, ys),
            width = maxX - minX,
            height = maxY - minY,
            x = center[0] - width / 2,
            y = center[1] - height / 2;


        return { x: x, y: y, width: width, height: height };
    }

    // transform bounds after zooming in/out
    function transformBounds(bounds) {
        return {
            x: bounds.x * state.transform.k + state.transform.x,
            y: bounds.y * state.transform.k + state.transform.y,
            width: bounds.width * state.transform.k,
            height: bounds.height * state.transform.k
        };
    }

    // check whether bbox of polygon in current viewport(canvas)
    function bboxInViewport(box) {
        const
            p1 = { x: box.x, y: box.y },
            p2 = { x: box.x + box.width, y: box.y },
            p3 = { x: box.x, y: box.y + box.height },
            p4 = { x: box.x + box.width, y: box.y + box.height },
            pointsInViewport = pointInViewport(p1) || pointInViewport(p2) || pointInViewport(p3) || pointInViewport(p4);

        return (pointsInViewport || viewportInBbox(p1, p2, p3, p4));
    }

    // check whether point of bbox in current viewport(canvas)
    function pointInViewport(p) {
        return (p.x >= state.MIN_WIDTH && p.x <= state.width() && p.y >= state.MIN_HEIGHT && p.y <= state.height());
    }

    // check whether current viewport(canvas) in chosen bbox of polygon
    function viewportInBbox(p1, p2, p3, p4) {
        const
            beyondWidth = p1.x < state.MIN_WIDTH && p3.x < state.MIN_WIDTH && p2.x > state.width() && p4.x > state.width(),
            beyondHeight = p1.y < state.MIN_HEIGHT && p2.y < state.MIN_HEIGHT && p3.y > state.height() && p4.y > state.height();

        return (beyondWidth || beyondHeight);
    }

    // get vertices from diagram.cell
    function getCellVertices(cell, diagram) {
        return cell.halfedges.map(i => cellHalfedgeStart(cell, diagram.edges[i]));
    }

    // relax sites, get average positions | reassign sites
    function relaxAndReassignSites(diagram) {
        return diagram.cells.map((cell, index) => getCellCentroidAndReassignSites(cell, diagram, index));
    }

    // get startPoint of edge
    function cellHalfedgeStart(cell, edge) {
        return edge[+(edge.left !== cell.site)];
    }

    // get endPoint of edge
    function cellHalfedgeEnd(cell, edge) {
        return edge[+(edge.left === cell.site)];
    }

    // context menu event
    function menu() {
        // condition of closing
        if (!state.EDIT_MODES.has('district') && !state.EDIT_MODES.has('building')) {
            d3.select('.d3-context-menu').remove();
        }
        let x = state.transform.invertX(state.pointer[0]);
        let y = state.transform.invertY(state.pointer[1]);
        let site = findSite(x, y);
        let percentMap = getAllTypes();

        if (site.isBoundary) {
            return [{
                title: 'Current Type: ' + site.type,
            },
            {
                title: `water: ${percentMap.get('water') || 0} / ${state.N}`,
                action: function () {
                    site.type = 'water';
                    site['elevation'] = state.waterline / 2;
                    site['affluence'] = state.waterline / 2;
                    assignSubPolygons(site.index);
                    render();
                },
                disabled: site.type === 'water' ? true : false
            },
            {
                title: `farm: ${percentMap.get('farm') || 0} / ${state.N}`,
                action: function () {
                    if (site.type === 'water') {
                        site['elevation'] = state.waterline === 1 ? 1 : state.waterline * 1.01;
                        site['affluence'] = 0;
                    }
                    site.type = 'farm';
                    assignSubPolygons(site.index);
                    render();
                },
                disabled: site.type === 'farm' ? true : false
            },
            {
                title: `empty: ${percentMap.get('empty') || 0} / ${state.N}`,
                action: function () {
                    if (site.type === 'water') {
                        site['elevation'] = state.waterline === 1 ? 1 : state.waterline * 1.01;
                        site['affluence'] = 0;
                    }
                    site.type = 'empty';
                    assignSubPolygons(site.index);
                    render();
                },
                disabled: site.type === 'empty' ? true : false
            }];
        }

        return [{
            title: 'Current Type: ' + site.type,
        },
        {
            divider: true
        },
        {
            title: `rich: ${percentMap.get('rich') || 0} / ${state.N}`,
            action: function () {
                resetElevationAndAffluence(site);
                site.type = 'rich';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'rich' ? true : false
        },
        {
            title: `medium: ${percentMap.get('medium') || 0} / ${state.N}`,
            action: function () {
                resetElevationAndAffluence(site);
                site.type = 'medium';

                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'medium' ? true : false
        },
        {
            title: `poor: ${percentMap.get('poor') || 0} / ${state.N}`,
            action: function () {
                resetElevationAndAffluence(site);
                site.type = 'poor';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'poor' ? true : false
        },
        {
            title: `plaza: ${percentMap.get('plaza') || 0} / ${state.N}`,
            action: function () {
                resetElevationAndAffluence(site);
                site.type = 'plaza';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'plaza' ? true : false
        },
        {
            title: `park: ${percentMap.get('park') || 0} / ${state.N}`,
            action: function () {
                resetElevationAndAffluence(site);
                site.type = 'park';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'park' ? true : false
        },
        {
            title: `university: ${percentMap.get('university') || 0} / ${state.N}`,
            action: function () {
                resetElevationAndAffluence(site);
                site.type = 'university';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'university' || Number(getAllTypes().get('university')) > 2.5 / 100 * state.N ? true : false
        },
        {
            title: `religious: ${percentMap.get('religious') || 0} / ${state.N}`,
            action: function () {
                resetElevationAndAffluence(site);
                site.type = 'religious';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'religious' || Number(getAllTypes().get('religious')) > 2.5 / 100 * state.N ? true : false
        },
        {
            title: `farm: ${percentMap.get('farm') || 0} / ${state.N}`,
            action: function () {
                resetElevationAndAffluence(site);
                site.type = 'farm';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'farm' ? true : false
        },
        {
            title: `water: ${percentMap.get('water') || 0} / ${state.N}`,
            action: function () {
                site.type = 'water';
                site['elevation'] = state.waterline / 2;
                site['affluence'] = state.waterline / 2;
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'water' ? true : false
        },
        {
            title: `harbor: ${percentMap.get('harbor') || 0} / ${state.N}`,
            action: function () {
                resetElevationAndAffluence(site);
                site.type = 'harbor';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'harbor' ? true : false
        },
        {
            title: `empty: ${percentMap.get('empty') || 0} / ${state.N}`,
            action: function () {
                site.type = 'empty';
                site['elevation'] = 0.35;
                site['affluence'] = 0;
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'empty' ? true : false
        }];
    };

    function resetElevationAndAffluence(site) {
        if (site.type === 'water') {
            site['elevation'] = state.waterline === 1 ? 1 : state.waterline * 1.01;
            site['affluence'] = state.waterline === 1 ? 1 : state.waterline / 2;
        }
    }

    /**
     * split 1 polygon into n sub-polygons
     * @param polygon: [vertex, vertex, ..., vertex]
     * @param n: number of sub-polygons
     * @param k: area ratio
     * @returns polygon [[0,1], ..., [0,1]]
     */
    function splitPolygon(type, poly, n, k) {
        if (n == 0) return { subPolygons: [], cutLines: [] };
        let subPoly = [poly];
        let cutLines = [];

        while (subPoly.length < n) {
            let p = subPoly.shift();
            let splitResult = splitPolyInto2(p, k);
            let poly1 = splitResult.poly1.poly.arrVector.map(p => [p.x, p.y]);
            let poly2 = splitResult.poly2.poly.arrVector.map(p => [p.x, p.y]);

            let end = [splitResult.cutLine.end.x, splitResult.cutLine.end.y];
            let start = [splitResult.cutLine.start.x, splitResult.cutLine.start.y]
            let streetName = state.STREET_NAMES[Math.floor(state.STREET_NAMES.length * Math.random())];
            let cutLine = [start, end, streetName];

            poly1.size = 10;
            poly2.size = 10;

            poly1.type = type;
            poly2.type = type;

            poly1.center = d3.polygonCentroid(poly1);
            poly2.center = d3.polygonCentroid(poly2);

            poly1.bounds = bounds(poly1, poly1.center);
            poly2.bounds = bounds(poly2, poly2.center);

            poly1.area = Math.abs(d3.polygonArea(poly1));
            poly2.area = Math.abs(d3.polygonArea(poly2));

            poly1.rotation = Math.random() > 0.5 ? Math.PI * 0.5 : Math.PI * 1;
            poly2.rotation = Math.random() > 0.5 ? Math.PI * 0.5 : Math.PI * 1;

            cutLines.push(cutLine);
            subPoly.push(poly1, poly2);
        }

        return { subPolygons: subPoly, cutLines: cutLines };
    }

    // split 1 polygon into 2 sub-polygons
    // polygon [[0,1], ... [0,1]]
    function splitPolyInto2(polygon, k) {
        let poly = new Polygon();
        let area = Math.abs(d3.polygonArea(polygon)) * k;

        polygon.forEach(v => poly.push_back(new Vector(v[0], v[1])));

        return poly.split(area);
    }

    // find the site when right clicking
    function findSite(x, y, radius) {
        var i = 0,
            n = state.graphics.sites.length,
            dx,
            dy,
            d2,
            site,
            closest;

        if (radius == null) radius = Infinity;
        else radius *= radius;

        for (i = 0; i < n; ++i) {
            site = state.graphics.sites[i];
            dx = x - site[0];
            dy = y - site[1];
            d2 = dx * dx + dy * dy;
            if (d2 < radius) closest = site, radius = d2;
        }

        return closest;
    }

    // find sites when dragging cursor
    function findSites(x, y, radius) {
        let i = 0,
            n = state.graphics.sites.length,
            dx,
            dy,
            d2,
            site,
            closest = [];

        if (radius == null) return;
        else radius *= radius;

        for (i = 0; i < n; ++i) {
            site = state.graphics.sites[i];
            dx = x - site[0];
            dy = y - site[1];
            d2 = dx * dx + dy * dy;
            site.delta = 1 - d2 / radius;
            if (d2 < radius) closest.push(site);
        }

        return closest;
    }

    // https://codeplea.com/triangular-interpolation
    // https://koozdra.wordpress.com/2012/06/27/javascript-is-point-in-triangle
    function getBarycentricValue(x1, x2, x3, y1, y2, y3, px, py) {
        const w1 = ((y2 - y3) * (px - x3) + (x3 - x2) * (py - y3)) / ((y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3));
        const w2 = ((y3 - y1) * (px - x3) + (x1 - x3) * (py - y3)) / ((y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3));
        const w3 = 1 - w1 - w2;

        return { w1: w1, w2: w2, w3: w3 };
    }

    /**
     * get point position in the edge that consists of site1 and site2
     * @param site1: [0, 1]
     * @param site2: [0, 1]
     * @param point: Number
     * @returns {* []}
    */
    function pointOnEdge(site1, site2, point, layer) {
        const lowest = site1[layer] < site2[layer] ? site1 : site2;
        const highest = lowest === site1 ? site2 : site1;
        const x = lowest[0] + (highest[0] - lowest[0]) * (point - lowest[layer]) / (highest[layer] - lowest[layer]);
        const k = slope(lowest[0], lowest[1], highest[0], highest[1]); // slope of line from site1 to site2
        const y = -k * (lowest[0] - x) + lowest[1];

        return [x, y];
    }

    /**
     * find adjacent sites on mouse position
     * @param  site 
     * @returns {Array}
    */
    function findAdjacentSites(index) {
        let sites = new Set();

        state.graphics.links.forEach(function (link) {
            if (link.source.index === index || link.target.index === index) {

                //get adjacent polygons
                state.graphics.polygons.forEach(function (p) {
                    if (state.graphics.sites[p.site].index === link.target.index || state.graphics.sites[p.site].index === link.source.index) {
                        sites.add(p.site);
                    }
                });
            }
        });

        return sites;
    }

    // combine different layers' color
    function combineColors(colors) {
        let r = 0, g = 0, b = 0, n = colors.length;
        colors.forEach(color => {
            r += Number(color[0]);
            g += Number(color[1]);
            b += Number(color[2]);
        });
        r /= n;
        g /= n;
        b /= n;

        return `rgb(${r}, ${g}, ${b})`;
    }

    // clear polygon's farms
    function clearSubPolygons(polygon) {
        if (!polygon.farms) return;

        polygon.farms.forEach(polygons => polygons.clear());
        polygon.farms = [];
    }

    // convert indexes of vertex to vertices
    function convert2Vertices(indexes) {
        return indexes.map(i => state.vertices[i]);
    }

    // convert edge-index to edge
    function convert2Edges(indexes) {
        return indexes.map(i => state.graphics.edges[i]);
    }

    // get adjacent sites' type
    function getAdjacentTypes(index) {
        let adjacentTypesSet = new Set();
        findAdjacentSites(index).forEach(s => adjacentTypesSet.add(state.graphics.sites[s].type));

        return adjacentTypesSet;
    }

    /**
     * get all sites' type
     * @returns {Map<any, any>}
    */
    function getAllTypes() {
        let map = new Map();

        state.DISTRICT_TYPES.forEach(type => {
            state.graphics.sites.forEach(s => {
                if (type !== s.type) return;
                if (map.has(type)) {
                    map.set(type, map.get(type) + 1);
                } else {
                    map.set(type, 1);
                }
            });
        });

        return map;
    }

    /**
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param midX
     * @param midY
     * @param d
     * @returns {{ x1: *, y1: *, x2: *, y2: *}}
     * @URL https://math.stackexchange.com/questions/306468/perpendicular-line-passing-through-the-midpoint-of-another-line
    */
    function getPerpendicularLineDestination(p1_x, p1_y, p2_x, p2_y, midX, midY, d) {
        let k1 = slope(p1_x, p1_y, p2_x, p2_y); // given segment slope
        let k2 = -1 / k1; // perpendicular line slope

        let x1 = midX + d / Math.sqrt(1 + sqr(k2));
        let y1 = midY + d * k2 / Math.sqrt(1 + sqr(k2));

        let x2 = midX - d / Math.sqrt(1 - sqr(k2));
        let y2 = midY - d * k2 / Math.sqrt(1 - sqr(k2));

        return { x1: x1, y1: y1, x2: x2, y2: y2 };
    }

    // compute topology based on value of `wall`
    function computeTopology(cells, edges) {
        var arcs = [],
            arcIndex = -1,
            arcIndexByEdge = {};

        return {
            objects: {
                voronoi: {
                    type: "GeometryCollection",
                    geometries: cells.map(function (cell) {
                        var site = state.graphics.sites[cell.site],
                            halfedges = cell.edges,
                            cellArcs = [],
                            clipArc = null;

                        halfedges.forEach(function (halfedge) {
                            var edge = edges[halfedge];
                            if (edge.hasOwnProperty('right') && edge.right !== null) {
                                var l = edge.left,
                                    r = edge.right,
                                    k = l + "," + r,
                                    i = arcIndexByEdge[k];
                                if (i == null) arcs[i = arcIndexByEdge[k] = ++arcIndex] = edge;
                                cellArcs.push(site.index === edge.left ? i : ~i);
                                clipArc = null;
                            } else if (clipArc) { // Coalesce border edges.
                                if (edge.hasOwnProperty('left') && edge.left !== null) edge = edge.slice(); // Copy-on-write.
                                clipArc.push(edge[1]);
                            } else {
                                arcs[++arcIndex] = clipArc = edge;
                                cellArcs.push(arcIndex);
                            }
                        });

                        // Ensure the last point in the polygon is identical to the first point.
                        var firstArcIndex = cellArcs[0],
                            lastArcIndex = cellArcs[cellArcs.length - 1],
                            firstArc = arcs[firstArcIndex < 0 ? ~firstArcIndex : firstArcIndex],
                            lastArc = arcs[lastArcIndex < 0 ? ~lastArcIndex : lastArcIndex];
                        lastArc[lastArcIndex < 0 ? 0 : lastArc.length - 1] = firstArc[firstArcIndex < 0 ? firstArc.length - 1 : 0].slice();

                        return {
                            type: "Polygon",
                            data: site,
                            arcs: [cellArcs]
                        };
                    }),
                }
            },
            arcs: arcs
        };
    }

    // set topology for drawing wall
    function setWallTopology() {
        let topology = computeTopology(state.graphics.polygons, state.graphics.edges);
        state.topology = topojson.merge(topology, topology.objects.voronoi.geometries.filter(d => d.data.wall > 0));
    }

    // get string of hashed string
    function hashEdge(edge) {
        return hashPoint(edge[0][0]) + hashPoint(edge[0][1]) + hashPoint(edge[1][0]) + hashPoint(edge[1][1]);
    }

    // truncate number to string
    function hashPoint(val) {
        return Math.floor(Number(val) * 100) + '';
    }

    /*=====================================================================================================
                                        Export Functions
    ======================================================================================================*/
    return {
        render: render,
        state: state,
        graphics: state.graphics,
        newGraphics: newGraphics,
        drawContourLine: drawContourLine,
        checkboxOnChange: checkboxOnChange,
        incrementSliderOnChange: incrementSliderOnChange,
        waterLineSliderOnChange: waterLineSliderOnChange,
        elevationSwitchOnChange: elevationSwitchOnChange,
        streetNameSwitchOnChange: streetNameSwitchOnChange,
    };

    // initialize some global variables and renew graphics
    function newGraphics(sites) {
        state.N = Math.abs(Number(sites)) > 512 ? 128 : Math.abs(Number(sites));
        state.vertices.clear();
        state.isAltPressed = false;
        state.topology = null;
        state.graphics.currentCastle = null;
        state.graphics = new Graphics();
        render();

        console.log("new graphics...", state.N);

        return state.graphics;
    }

    // draw contour line
    function drawContourLine() {
        if (state.LAYERS.has(elevation)) {
            render();
            drawContourLines(state.context(), state.waterline, 'elevation', 'blue', 4.5);
            drawContourLines(state.context(), 0.10, 'elevation', 'blue', 4.5);
            drawContourLines(state.context(), 0.15, 'elevation', 'blue', 4.5);
            drawContourLines(state.context(), 0.20, 'elevation', 'blue', 4.5);
            drawContourLines(state.context(), 0.25, 'elevation', 'red', 4.5);
            drawContourLines(state.context(), 0.5, 'elevation', 'green', 4.5);
            drawContourLines(state.context(), 0.75, 'elevation', 'yellow', 4.5);
        }
    }

    function streetNameSwitchOnChange(value) {
        state.showStreetNames = value;
        render();
    }

    function checkboxOnChange(type, layer, isChecked) {
        switch (layer) {
            case 'elevation': layerOnChange(type, isChecked, elevation, 'elevation'); break;
            case 'affluence': layerOnChange(type, isChecked, affluence, 'affluence'); break;
            case 'desirability': layerOnChange(type, isChecked, desirability, 'desirability'); break;
            case 'district': layerOnChange(type, isChecked, district, 'district'); break;
            case 'building': layerOnChange(type, isChecked, building, 'building'); break;
        }
    }

    // view + edit
    function layerOnChange(type, isChecked, viewLayer, editLayer) {
        if (type === 'view') {
            if (isChecked) {
                state.LAYERS.add(viewLayer);
            } else {
                if (state.LAYERS.size === 1) {
                    this.checked = true;
                    return;
                } else if (state.LAYERS.has(viewLayer)) {
                    state.LAYERS.delete(viewLayer);
                    state.EDIT_MODES.delete(editLayer);
                }
            }
        } else if (type === 'edit') {
            if (isChecked) {
                state.LAYERS.add(viewLayer);
                state.EDIT_MODES.add(editLayer);
            } else {
                state.EDIT_MODES.delete(editLayer);
            }
        } else {
            console.error('error: wrong layer type');
        }
        render();
    }

    // onChange event of increment slider
    function incrementSliderOnChange(value) {
        state.increment = value;
    }

    // onChange event of waterline slider
    function waterLineSliderOnChange(value) {
        state.waterline = value;
        onChangeWaterLine();
        drawContourLines(state.context(), state.waterline, 'elevation', 'blue', 4.5);
    }

    // onChange event of elevation switch
    function elevationSwitchOnChange(isChecked) {
        state.isIncreasing = !isChecked;
    }
}