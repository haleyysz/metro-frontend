'use strict';

// clear array
Array.prototype.clear = function () {
    while (this.length) {
        this.pop();
    }
};

// check whether an object is empty
function isEmpty(obj) {
    return !Object.keys(obj).length > 0;
}

function Metro(canvas, cursorCanvas, data) {

    /*=====================================================================================================
                                             Constructors
    ======================================================================================================*/
    // elevation layer
    var elevation = (site_index) => {
        let value = state.graphics.sites[site_index]['elevation'];
        let grayScale = ((1 - value) * 255).toFixed(1);

        if (value <= state.waterline) {
            // set color for river in [elevation] mode
            return [51, 102, 153]; // lightBlue
        }

        return [grayScale, grayScale, grayScale];
    };

    // affluence layer
    var affluence = (site_index) => {
        let value = state.graphics.sites[site_index]['affluence'];
        let grayScale = ((1 - value) * 255).toFixed(1);

        return [grayScale, grayScale, grayScale];
    };

    // desirability layer
    var desirability = (site_index) => {
        let site = state.graphics.sites[site_index];
        let value = (site['elevation'] + site['affluence']) / 2;
        if (site['elevation'] <= state.waterline) value = 0;
        let grayScale = ((1 - value) * 255).toFixed(1);

        return [grayScale, grayScale, grayScale];
    };

    // district layer
    var district = (site_index) => {
        let site = state.graphics.sites[site_index];

        return state.POLYGON_TYPE_COLOR[site.type] || [255, 255, 255];
    };

    // building layer
    var building = (site_index) => {
        let site = state.graphics.sites[site_index];

        return state.POLYGON_TYPE_COLOR[site.type];
    }

    var state = {
        N: $('#input-sites').val() || 100,
        LAYERS: new Set([elevation]),
        EDIT_MODES: new Set(),
        LAYER: 'elevation',
        radius: 100,
        increment: $('#incrementSlider').val() || .15,
        waterline: $('#waterLineSlider').val() || .15,
        pointer: {},
        vertices: data ? data.vertices.map(vertex2Array) : [],
        buildings: [],
        contourLines: [],
        selectedSites: [],
        isDragging: false,
        isIncreasing: true,
        isAltPressed: false,
        transform: d3.zoomIdentity, // scale parameter of zoom
        canvas: canvas || d3.select("#myCanvas").node(),
        cursorCanvas: cursorCanvas || d3.select("#cursorCanvas").node(),
        width() {
            return this.canvas.width;
        },
        height() {
            return this.canvas.height;
        },
        context() {
            return this.canvas.getContext("2d", { antialias: true, depth: true });
        },
        cursorContext() {
            return this.cursorCanvas.getContext("2d", { antialias: true, depth: true });
        },
        DISTRICT_TYPES: ['rich', 'medium', 'poor', 'plaza', 'empty', 'water', 'farm', 'park', 'castle', 'harbor', 'military', 'religious', 'university'],
        COLOR: [{ R: 255, G: 0, B: 0 }, { R: 0, G: 255, B: 0 }, { R: 0, G: 0, B: 255 }],
        RANDOM_COLOR: d3.scaleOrdinal().range(d3.schemeCategory20), // random color
        POLYGON_TYPE_COLOR: {
            'rich': [152, 134, 148], // purple
            'medium': [161, 147, 127], // rice
            'poor': [103, 99, 92], // grey
            'plaza': [242, 233, 58], // yellow
            'farm': [253, 242, 205], // light yellow #cbc5b9
            'empty': [203, 197, 185], // light yellow #cbc5b9
            'water': [51, 102, 153], // light blue
            'park': [3, 165, 44], // light green
            'castle': [255, 255, 255], // white
            'harbor': [117, 123, 124], // light blue
            'military': [75, 83, 32], // army green
            'religious': [255, 255, 255], // white
            'university': [140, 20, 60], // red
        },
    };
    state.graphics = new Graphics();
    console.log("loading...", state.graphics);
    render();

    // initialize mouse event
    d3.select(state.cursorCanvas)
        .call(d3.drag()
            .container(state.cursorCanvas)
            .subject(dragsubject)
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended))
        .on("wheel", onScroll)
        .on("mousemove", onMouseMove)
        .on("contextmenu", d3.contextMenu(menu))
        .call(d3.zoom().scaleExtent([1, 8]).on("zoom", zoomed));

    // initialize key event
    d3.select("body")
        .on("keyup", onKeyUp)
        .on("keydown", onKeyDown);

    /*=====================================================================================================
                                             Main Functions
    ======================================================================================================*/
    function Graphics() {
        const MIN_WIDTH = 20;
        const MIN_HEIGHT = 20;
        const MAX_WIDTH = state.width() - 20;
        const MAX_HEIGHT = state.height() - 20;

        this.currentCastle = data ? data.currentCastle : null;

        this.sites = data ? data.sites.map(site2Array) : d3.range(state.N).map(() => [Math.random() * (MAX_WIDTH - MIN_WIDTH) + MIN_WIDTH, Math.random() * (MAX_HEIGHT - MIN_HEIGHT) + MIN_HEIGHT, 0]);
        this.voronoi = d3.voronoi().extent([[MIN_WIDTH, MIN_HEIGHT], [MAX_WIDTH, MAX_HEIGHT]]);
        this.diagram = data ? diagram2Array(data.diagram) : this.voronoi(this.sites);

        // relax sites in using Lloyd's algorithm and delete duplicated data
        if (!data) {
            for (let n = 0; n < 5; n++) {
                this.sites = relax(this.diagram);
                this.diagram = this.voronoi(this.sites);
            }
        }

        this.edges = data ? data.edges.map(edge2Array) : this.diagram.edges;
        this.links = data ? data.links : this.diagram.links();
        this.triangles = data ? data.triangles.map(t => t.map(site2Array)) : this.diagram.triangles();
        this.polygons = data ? data.polygons.map(polygon2Array) : makePolygons(this.sites, this.diagram);
        this.vertices = state.vertices;
        this.buildings = state.buildings;
    }

    // convert stored polygon JSON to d3 object
    function polygon2Array(json) {
        let poly = JSON.parse(json);

        // convert polygon.center
        if (poly.hasOwnProperty('center') && !isEmpty(poly.center)) {
            if (poly.center.hasOwnProperty('clear')) delete poly.center['clear'];
            if (poly.center.hasOwnProperty('length')) delete poly.center['length'];

            poly.center = [poly.center[0], poly.center[1]];
        }

        // convert polygon.vertices
        if (poly.hasOwnProperty('vertices') && !isEmpty(poly.vertices)) {
            if (poly.vertices.hasOwnProperty('clear')) delete poly.vertices['clear'];
            if (poly.vertices.hasOwnProperty('length')) delete poly.vertices['length'];
            let object = poly.vertices, array = [];

            for (let property in object) {
                if (object.hasOwnProperty(property)) {
                    if (property !== 'length') {
                        array.push(Number(object[property]));
                    }
                }
            }
            poly.vertices = array;
        }

        // convert polygon.edges
        if (poly.hasOwnProperty('edges') && !isEmpty(poly.edges)) {
            if (poly.edges.hasOwnProperty('clear')) delete poly.edges['clear'];
            if (poly.edges.hasOwnProperty('length')) delete poly.edges['length'];
            let object = poly.edges, array = [];

            for (let property in object) {
                if (object.hasOwnProperty(property)) {
                    if (property !== 'length') {
                        array.push(Number(object[property]));
                    }
                }
            }
            poly.edges = array;
        }

        // convert polygon.subPolygons
        if (poly.hasOwnProperty('subPolygons') && !isEmpty(poly.subPolygons)) {
            if (poly.subPolygons.hasOwnProperty('clear')) delete poly.subPolygons['clear'];
            if (poly.subPolygons.hasOwnProperty('length')) delete poly.subPolygons['length'];

            let object = poly.subPolygons, array = [];

            // Level 1: {0: {asdasd}, 1: {asd}, 2: {asd}}
            for (let property in object) {
                let subArray = [];

                // Level 2: {0: {asdasd}, 1: {asd}, 2: {asd}}
                for (let subProperty in object[property]) {
                    if (object[property].hasOwnProperty('length')) delete object[property]['length'];

                    if (subProperty !== 'center' && subProperty !== 'color' && subProperty !== 'rotation' && subProperty !== 'size' && subProperty !== 'length') {
                        if (object[property][subProperty][0] && object[property][subProperty][1]) {
                            subArray.push([object[property][subProperty][0], object[property][subProperty][1]]);
                        }
                    } else {
                        if (subProperty === 'center') {
                            subArray.center = [object[property]['center'][0], object[property]['center'][1]];
                        } else if (subProperty === 'color') {
                            subArray.color = [object[property]['color'][0], object[property]['color'][1], object[property]['color'][2]];
                        } else if (subProperty === 'rotation') {
                            subArray.rotation = object[property]['rotation'];
                        } else if (subProperty === 'size') {
                            subArray.size = object[property]['size'];
                        } else if (subProperty === 'type') {
                            subArray.size = object[property]['type'];
                        } else if (subProperty === 'bounds') {
                            subArray.size = object[property]['bounds'];
                        } else if (subProperty === 'buildings') {
                            subArray.size = object[property]['buildings'];
                        } else if (subProperty === 'simulation') {
                            subArray.size = object[property]['simulation'];
                        }
                    }
                }
                array.push(subArray);
            }
            poly.subPolygons = array;
        } else {
            poly.subPolygons = [];
        }

        // convert polygon.farms
        if (poly.hasOwnProperty('farms') && !isEmpty(poly.farms)) {
            if (poly.farms.hasOwnProperty('clear')) delete poly.farms['clear'];
            if (poly.farms.hasOwnProperty('length')) delete poly.farms['length'];
            let object = poly.farms, array = [];

            // Level 1: {0: {asdasd}, 1: {asd}, 2: {asd}}
            for (let property in object) {
                let subArray = [];

                // Level 2: {0: {asdasd}, 1: {asd}, 2: {asd}}
                for (let subProperty in object[property]) {
                    if (object[property].hasOwnProperty('length')) delete object[property]['length'];

                    if (subProperty !== 'center' && subProperty !== 'pattern' && subProperty !== 'rotation' && subProperty !== 'size' && subProperty !== 'length') {
                        subArray.push([object[property][subProperty][0], object[property][subProperty][1]]);
                    } else {
                        if (subProperty === 'center') {
                            subArray.center = [object[property]['center'][0], object[property]['center'][1]];
                        } else if (subProperty === 'color') {
                            subArray.color = [object[property]['color'][0], object[property]['color'][1], object[property]['color'][2]];
                        } else if (subProperty === 'pattern') {
                            subArray.pattern = object[property]['pattern'];
                        } else if (subProperty === 'rotation') {
                            subArray.rotation = object[property]['rotation'];
                        } else if (subProperty === 'size') {
                            subArray.size = object[property]['size'];
                        }
                    }
                }
                array.push(subArray);
            }
            poly.farms = array;
        } else {
            poly.farms = [];
        }
        return poly;
    }

    // convert stored site object to d3 object
    function site2Array(s) {
        // let json = JSON.parse(s);
        // if (json.hasOwnProperty('clear')) delete json['clear'];
        // if (json.hasOwnProperty('length')) delete json['length'];
        // return json;
        let site = [s.x, s.y];
        site.index = s.index;
        site.type = s.type;
        site.delta = s.delta;
        site.isBoundary = s.isBoundary;
        site.elevation = s.elevation;
        site.affluence = s.affluence;
        site.desirability = s.desirability;
        site.wall = s.wall;
        site.color = s.color;

        return site;
    }

    // convert stored diagram object to d3 object
    function diagram2Array(diagram) {
        diagram.edges = diagram.edges.map(edge2Array);
        diagram.cells = diagram.cells.map(cell => {
            let newCell = {
                halfedges: cell.halfedges,
                site: [],
            }
            newCell.site[0] = cell.site.x;
            newCell.site[1] = cell.site.y;
            newCell.site.index = cell.site.index;
            newCell.site.data = cell.site.data;
            return newCell;
        });

        return diagram;
    }

    // convert Object(edge) to Array(edge)
    function edge2Array(e) {
        if (e === null || e === undefined) return;

        let edge = [];
        edge[0] = state.vertices[e.startPoint.vertexIndex];
        edge[1] = state.vertices[e.endPoint.vertexIndex];
        edge.left = [e.left.x, e.left.y];
        edge.left.index = e.left.index;
        edge.left.data = e.left.data;

        if (e.right) {
            edge.right = [e.right.x, e.right.y];
            edge.right.index = e.right.index;
            edge.right.data = e.right.data;
        }

        return edge;
    }

    function vertex2Array(v) {
        let vertex = [];
        vertex.push(v.x);
        vertex.push(v.y);
        vertex.edgeIndex = v.edgeIndex;
        vertex.vertexIndex = v.vertexIndex;

        return vertex;
    }

    function getCellCentroid(cell, diagram, index) {
        let cx = 0, cy = 0, count = 0;

        getCellVertices(cell, diagram).forEach(v => {
            cx += v[0];
            cy += v[1];
            count++;
        });

        let site = [cx / count, cy / count];
        site.index = index;
        site.type = 'empty';
        site.isBoundary = false;
        site.elevation = 0.35;
        site.affluence = 0;
        site.desirability = 0;
        site.wall = 0;
        site.color = { R: Math.random() * 255, G: Math.random() * 255, B: Math.random() * 255 };

        return site;
    }

    // make polygons(districts)
    function makePolygons(sites, diagram) {
        return diagram.cells.map((cell, index) => {
            let polygon = {
                index: index,
                area: null,
                center: null,
                vertices: null,
                subPolygons: [],
                farms: [],
                isBoundary: false,
                edges: cell.halfedges, // an array of indexes into diagram.edges
            };

            polygon.vertices = cell.halfedges.map(i => {
                polygon.site = cell.site.index;
                diagram.edges[i].forEach(edge => {
                    if (edge.includes(20) || edge.includes(state.width() - 20) || edge.includes(state.height() - 20)) {
                        polygon.isBoundary = true;
                        sites[index].isBoundary = true;
                    }
                });

                let startVertex = cellHalfedgeStart(cell, diagram.edges[i]);
                startVertex.edgeIndex = i;
                startVertex.vertexIndex = state.vertices.length;
                state.vertices.push(startVertex);

                let endVertex = cellHalfedgeEnd(cell, diagram.edges[i]);
                if (!endVertex.hasOwnProperty('edgeIndex') || !endVertex.hasOwnProperty('vertexIndex')) {
                    endVertex.edgeIndex = i;
                    endVertex.vertexIndex = state.vertices.length;
                    state.vertices.push(endVertex);
                }

                return startVertex.vertexIndex;
            });

            let vertices = polygon.vertices.map(v => state.vertices[v]);
            polygon.center = d3.polygonCentroid(vertices);
            polygon.area = Math.abs(d3.polygonArea(vertices));

            return polygon;
        });
    }

    // render
    function render() {
        state.context().save();
        state.cursorContext().clearRect(0, 0, state.width(), state.height());
        state.context().clearRect(0, 0, state.width(), state.height());
        state.context().translate(state.transform.x, state.transform.y);
        state.context().scale(state.transform.k, state.transform.k);

        /* draw districts */
        drawDistricts();

        /* draw subPolygons */
        if (state.LAYERS.has(building)) drawSubPolygons();

        /* draw buildings */
        if (state.LAYERS.has(building) && state.transform.k >= 2) {
            drawBuildings();
        }
        // if (state.LAYERS.has(building)) drawBuildings();

        // drawTriangles();
        // renderBackground();
        // drawSites(2, 'black'); // lineWidth, lineColor
        // drawEdges(3, 'black'); // lineWidth, lineColor

        /* draw docks */
        if (state.LAYERS.has(building)) drawDock('rgb(233, 233, 233)', 'rgb(233, 233, 233)', 8); // bgColor, edgeColor, lineWidth

        /* draw walls */
        if (state.LAYERS.has(district)) drawContourLines(0.25, 'wall', 'black', 8, true, false);

        state.context().restore();
    }

    /**
     * assign type to site(polygon/district)
     *  @param waterline
     *  @param elevation
     *  @param affluence
     *  @param desirability = (elevation + affluence) / 2
     *  rich: 0.75 <= desirability <= 1
     *  medium: 0.5 < desirability < 0.75
     *  poor: waterline < desirability <= 0.5
     *  plaza: AdjacentSites.contains(`poor` && `medium` && `rich`)
     *  water: elevation <= waterline
     *  farm: waterline < desirability && elevation <= 0.5
     *  empty: value = 0 || (isBoundary && !water)
     */
    function assignType4Site(index) {
        let s = state.graphics.sites[index];
        let value = (s['elevation'] + s['affluence']) / 2;
        let adjacentTypesMap = new Map();
        let adjacentTypesSet = getAdjacentTypes(s.index); // get all adjacent types -> Set<>

        if (value >= 0.8 && value <= 1) {
            s.type = 'rich';
        } else if (value < 0.8 && value > 0.6) {
            s.type = 'medium';
        } else if (value <= 0.6 && value > state.waterline) {
            s.type = 'poor';
        } else if (value === 0) {
            s.type = 'empty';
        }

        // findAdjacentSites(s.index).forEach(s => adjacentTypesSet.add(state.graphics.sites[s].type));

        // get all adjacent types' frequencies
        [...findAdjacentSites(s.index)]
            .map(s => state.graphics.sites[s].type)
            .forEach(s => {
                if (adjacentTypesMap.has(s)) {
                    adjacentTypesMap.set(s, adjacentTypesMap.get(s) + 1);
                } else {
                    adjacentTypesMap.set(s, 1);
                }
            });

        // assign type `plaza` for district only if it is adjacent to `poor` && `medium` && `rich`
        if (adjacentTypesSet.size === 3 && adjacentTypesSet.has('poor') && adjacentTypesSet.has('medium') && adjacentTypesSet.has('rich')) {
            s.type = Math.random() > 0.5 ? 'plaza' : 'park';
        }

        // assign type `university`
        if (adjacentTypesMap.get('rich') >= 3) {
            s.type = 'university';
        }

        // assign type `park`
        if (adjacentTypesMap.get('rich') >= 4) {
            // s.type = 'park';
        }

        // assign type `water`
        if (s['elevation'] <= state.waterline) {
            s.type = 'water';
            s.wall = 0;
        }

        // assign type `harbor`
        if (s.type !== 'water' && adjacentTypesSet.has('poor') && adjacentTypesSet.has('water')) {
            s.type = 'harbor';
            s.wall = 0;
        }

        // assign type `farm` and `empty`
        if (value <= 0.45 && value > state.waterline) {
            if (!adjacentTypesSet.has('water')) {
                s.type = 'farm';
            } else {
                s.type = 'empty';
            }
        }

        // boundaries can only be assigned as 'empty' or 'water'
        if (s.isBoundary && s.type !== 'water') {
            s.type = Math.random() > 0.5 ? 'empty' : 'farm';
        }

        // randomly assign `religious`
        if (!s.isBoundary && s.type !== 'water' && Number(getAllTypes().get('religious')) <= 2.5 / 100 * state.N) {
            if (Math.random() > 0.99) {
                s.type = 'religious';
            }
        }

        // split polygons and assign subPolygons for polygon
        assignSubPolygons(index);
    }

    // make sub-polygons/subPolygons
    function assignSubPolygons(index) {
        const SUBPOLYGONS_NUMBER = {
            'rich': Math.round(Math.random() * 2 + 4),
            'medium': Math.round(Math.random() * 8 + 8),
            'poor': Math.round(Math.random() * 10 + 10),
            'plaza': Math.round(Math.random() * 2 + 2),
            'farm': Math.round(Math.random() * 10 + 10),
            'park': 0,
            'empty': 0,
            'water': 0,
            'castle': 0, // 1
            'harbor': Math.round(Math.random() * 4 + 8), // docks
            'military': Math.round(Math.random() * 2 + 6),
            'religious': Math.round(Math.random() * 2 + 4),
            'university': Math.round(Math.random() * 1 + 5),
        };

        let polygon = state.graphics.polygons[index],
            site = state.graphics.sites[index],
            size = SUBPOLYGONS_NUMBER[site.type],
            k = Math.random() * 0.6 + 0.2,
            vertices = convert2Vertices(polygon.vertices),
            resultArr = splitPolygon(site.type, vertices, size, k);

        if (resultArr !== 0 || resultArr.length) {
            resultArr.forEach(r => r.color = state.POLYGON_TYPE_COLOR[site.type]);
        }

        polygon.subPolygons = resultArr;

        // determine numbers of farms and subPolygons of type `farm`
        if (site.type === 'farm') {
            size = Math.round(Math.random() * 4 + 2);
            polygon.farms = splitPolygon(site.type, vertices, size, 0.5);
            // polygon.farms.forEach(sp => sp.pattern = state.context().createPattern(makeDiagonalPattern(sp), "repeat"));
            polygon.subPolygons = Math.random() > 0.9 ? [polygon.subPolygons.pop()] : [];
        } else {
            clearSubPolygons(polygon);

            if (site.type === 'plaza') {
                // determine number of subPolygons of type `plaza`
                polygon.subPolygons = Math.random() > 0.5 ? [polygon.subPolygons.pop(), polygon.subPolygons.pop()] : [polygon.subPolygons.pop()];

            } else if (site.type === 'military') {
                // determine number of subPolygons of type `military`
                resultArr = splitPolygon(site.type, vertices, size, 0.5);
                resultArr.forEach(r => r.color = state.POLYGON_TYPE_COLOR[site.type]);
                polygon.subPolygons = resultArr;
            } else {
                // while (size > 0) {
                //     size = size % 5 - 1;
                //     polygon.subPolygons.splice(Math.floor(Math.random() * polygon.subPolygons.length), 1, []);
                // }

                // determine number of subPolygons of other types
                if (polygon.subPolygons.length > 0) {
                    polygon.subPolygons = polygon.subPolygons.filter(sub => sub.area >= polygon.area / 20);
                }
            }
            // make buildings with simulations
            polygon.subPolygons = polygon.subPolygons
                .map(makeBuildings)
                .map(makeSimulations);
        }
    }

    function makeSimulations(polygon) {
        let distance = Math.max(polygon.bounds.width, polygon.bounds.height) / 2;
        polygon.simulation = d3.forceSimulation(polygon.buildings)
            .force("center", d3.forceCenter(polygon.center[0], polygon.center[1]))
            .force("collide", d3.forceCollide(d => d.radius + 1).iterations(2))
            .force("polygonCollide", forceCollidePolygon(polygon))
            .force("myForce", myForce().distanceMin(1).distanceMax(distance).iterations(4))
            .on("tick", render);

        // stop simulation in 2seconds
        setTimeout(() => polygon.simulation.stop(), 5000);
        return polygon;
    }

    function makeBuildings(poly) {
        const width = poly.bounds.width;
        const BUILDINGS_NUMBER = {
            'rich': Math.sqrt(Math.sqrt(poly.area)),
            'medium': Math.sqrt(Math.sqrt(poly.area)),
            'poor': Math.sqrt(Math.sqrt(poly.area)),
            'plaza': Math.sqrt(Math.sqrt(Math.sqrt(poly.area))),
            'farm': 0,
            'park': 0,
            'empty': 0,
            'water': 0,
            'castle': 0,
            'harbor': Math.sqrt(Math.sqrt(poly.area)),
            'military': Math.sqrt(Math.sqrt(poly.area)),
            'religious': Math.sqrt(Math.sqrt(poly.area)),
            'university': Math.sqrt(Math.sqrt(poly.area)),
        };
        const BUILDINGS_SIZE = {
            'rich': width / 8,
            'medium': width / 10,
            'poor': width / 12,
            'plaza': width / 6,
            'farm': 0,
            'park': 0,
            'empty': 0,
            'water': 0,
            'castle': 0,
            'harbor': width / 12,
            'military': width / 8,
            'religious': width / 12,
            'university': width / 8,
        };
        const number = BUILDINGS_NUMBER[poly.type];
        let dots = d3.range(number).map(() => {
            let d = {
                x: null,
                y: null,
                fx: null,
                fy: null,
                vx: null,
                vy: null,
                sign: null,
                width: null,
                height: null,
                radius: null,
                offset: null,
                orientation: 0.0,
                // parent: poly.index,
                random: Math.random(),
            };
            d.width = BUILDINGS_SIZE[poly.type];
            d.height = BUILDINGS_SIZE[poly.type];
            d.sign = d.random < 0.5 ? -1 : 1;
            d.offset = { x: Math.round(Math.random() * d.width / 2), y: Math.round(Math.random() * d.height / 2) };
            d.radius = Math.sqrt(sqr(d.width / 2) + sqr(d.height / 2));
            // d.index = state.buildings.length;
            // state.buildings.push(d);
            return d;
        });
        poly.buildings = dots;

        return poly;
    }

    /**
     * assign type `castle`
     *
     * @TODO
     * find sites adjacent to s[`castle`],  s.wall = everySite.wall === 0.5 ? 0 : 0.5;
     */
    function assignCastle4Site() {
        let site = null;
        let sites = state.graphics.sites.filter(s => s.type !== 'water' && s.type !== 'harbor');

        if (sites.length > 0) {
            // find max desirability
            site = sites.reduce((current, next) => current['desirability'] > next['desirability'] ? current : next);

            if (state.graphics.currentCastle && site.index !== state.graphics.currentCastle) {
                let newDesirability = state.graphics.sites[site.index]['desirability'];
                let oldDesirability = state.graphics.sites[state.graphics.currentCastle]['desirability'];
                if (newDesirability > oldDesirability) {
                    // reassign old one
                    state.graphics.sites[state.graphics.currentCastle].wall = 0;
                    assignType4Site(state.graphics.currentCastle);
                }
            }

            // assign `castle`
            assignMilitary4Site(site.index);
            site.wall = 0.5;
            site.type = 'castle';
            state.graphics.currentCastle = site.index;
            assignSubPolygons(site.index);
        }
    }

    // assign type `military`
    function assignMilitary4Site(index) {
        // reassign old military
        reassignMilitarySites();

        // get all adjacent types
        findAdjacentSites(index).forEach(i => {
            if (state.graphics.sites[i].type !== 'water' && state.graphics.sites[i].type !== 'harbor') {
                state.graphics.sites[i].type = 'military';
                assignSubPolygons(i);
            }
        });
    }

    //  reassign military sites
    function reassignMilitarySites() {
        state.graphics.sites
            .filter(s => s.type === 'military')
            .forEach(s => {
                let adjacentTypesSet = getAdjacentTypes(s.index); // get all adjacent districts types
                if (!adjacentTypesSet.has('castle')) {
                    assignType4Site(s.index);
                }
            });
    }

    // on changing waterline
    function onChangeWaterLine() {
        state.graphics.sites.forEach(s => assignType4Site(s.index));
        assignCastle4Site();
        render();
    }

    /*=====================================================================================================
                                             Event Functions
    ======================================================================================================*/
    function dragsubject() {
        if (state.isAltPressed) {
            return null;
        } else {
            return 0;
        }
    }

    function dragstarted() {
        if (state.EDIT_MODES.size >= 1 && !state.isAltPressed) {
            d3.contextMenu('close');
            state.isDragging = true;
        }
    }

    function dragged() {
        if (state.EDIT_MODES.size >= 1 && state.isDragging) {
            state.pointer = d3.mouse(this);

            let x = state.transform.invertX(state.pointer[0]);
            let y = state.transform.invertY(state.pointer[1]);
            state.selectedSites.clear();
            state.selectedSites = findSites(x, y, state.radius);

            if (state.isIncreasing) {
                if (state.selectedSites.length > 0) {
                    state.selectedSites.map(s => {
                        if (state.EDIT_MODES.has('district')) {
                            s['wall'] = 0.5;
                            if (s.type === 'water') s['wall'] = 0;
                        }
                        if (state.EDIT_MODES.has('elevation')) {
                            s['elevation'] += state.increment * s.delta;
                            s['desirability'] += state.increment * s.delta;
                        }
                        if (state.EDIT_MODES.has('affluence')) {
                            s['affluence'] += state.increment * s.delta;
                            s['desirability'] += state.increment * s.delta;
                        }
                        if (state.EDIT_MODES.has('desirability') && state.EDIT_MODES.size === 1) {
                            s['elevation'] += (state.increment * s.delta) / 10;
                            s['affluence'] += (state.increment * s.delta) / 10 * 9;
                            s['desirability'] += (state.increment * s.delta) / 10 * 5;
                        }
                        if (s['elevation'] >= 1) s['elevation'] = 1;
                        if (s['affluence'] >= 1) s['affluence'] = 1;
                        if (state.EDIT_MODES.has('elevation') || state.EDIT_MODES.has('affluence')) {
                            assignType4Site(s.index);
                        }
                    });
                }
            } else {
                if (state.selectedSites.length > 0) {
                    state.selectedSites.map(s => {
                        if (state.EDIT_MODES.has('district')) {
                            s['wall'] = 0;
                        }
                        if (state.EDIT_MODES.has('elevation')) {
                            s['elevation'] -= state.increment * s.delta;
                            s['desirability'] -= state.increment * s.delta;
                        }
                        if (state.EDIT_MODES.has('affluence')) {
                            s['affluence'] -= state.increment * s.delta;
                            s['desirability'] -= state.increment * s.delta;
                        }
                        if (state.EDIT_MODES.has('desirability') && state.EDIT_MODES.size === 1) {
                            s['elevation'] -= (state.increment * s.delta) / 10;
                            s['affluence'] -= (state.increment * s.delta) / 10 * 9;
                            s['desirability'] -= (state.increment * s.delta) / 10 * 5;
                        }
                        if (s['elevation'] <= 0) s['elevation'] = 0;
                        if (s['affluence'] <= 0) s['affluence'] = 0;
                        if (state.EDIT_MODES.has('elevation') || state.EDIT_MODES.has('affluence')) {
                            assignType4Site(s.index);
                        }
                    });
                }
            }
            render();
            if (!(state.EDIT_MODES.has('building') && state.EDIT_MODES.size === 1)) drawCursor('red');
        }
    }

    function dragended() {
        if (state.EDIT_MODES.size >= 1 && state.isDragging) {
            // after drag end, assign type `castle`
            assignCastle4Site();
            state.isDragging = false;
            render();
        }
    }

    // mouse event
    function onMouseMove() {
        if (!state.isAltPressed && state.EDIT_MODES.size >= 1) {
            state.pointer = d3.mouse(this);
            if (!(state.EDIT_MODES.has('building') && state.EDIT_MODES.size === 1)) {
                drawCursor('red');
            }
        }
    }

    function onScroll() {
        if (!state.isAltPressed && state.EDIT_MODES.size >= 1) {
            state.radius -= d3.event.deltaX;
            state.radius -= d3.event.deltaY;

            if (state.radius < 15) state.radius = 15;
            if (state.radius > 700) state.radius = 700;
            if (!(state.EDIT_MODES.has('building') && state.EDIT_MODES.size === 1)) {
                drawCursor('red');
            }
        }
    }

    // set zoom arguments
    function zoomed() {
        if (state.isAltPressed) {
            state.transform = d3.event.transform;
            render();
        }
    }

    function onKeyDown() {
        if (d3.event.altKey) state.isAltPressed = true;

        if (d3.event.keyCode === 13) {
            let sites = $('#input-sites').val();
            if (!sites.isNaN) {
                newGraphics(sites);
            }
        }
    }

    function onKeyUp() {
        state.isAltPressed = state.isAltPressed ? false : true;
    }

    /*=====================================================================================================
                                             Draw Functions
    ======================================================================================================*/

    /**
     * Creates a canvas filled with a 45-degree pinstripe.
     * @returns {HTMLCanvasElement}
     */
    function makeDiagonalPattern(sub) {

        let canvasPattern = document.createElement("canvas");
        canvasPattern.width = sub.size;
        canvasPattern.height = sub.size;
        let contextPattern = canvasPattern.getContext("2d", { antialias: true, depth: false });
        contextPattern.clearRect(0, 0, canvasPattern.width, canvasPattern.height);

        // draw pattern to off-screen context
        contextPattern.beginPath();

        contextPattern.translate(sub.size / 2, sub.size / 2);
        contextPattern.rotate(sub.rotation);
        contextPattern.translate(-sub.size / 2, -sub.size / 2);

        contextPattern.moveTo(0, 0);
        contextPattern.lineTo(canvasPattern.width, canvasPattern.height);
        contextPattern.stroke();

        return canvasPattern;
    }

    // draw districts
    function drawDistricts() {
        state.context().save();

        state.graphics.polygons.forEach(p => {
            let site = state.graphics.sites[p.index];
            let colors = [...state.LAYERS].map(layer => layer(p.site));
            let color = combineColors(colors);

            // start drawing polygon
            state.context().beginPath();
            // state.context().fillStyle = site.type === 'water' ? 'rgb(51, 102, 153)' : 'rgb(203, 197, 185)';

            if (site.type === 'farm' && state.LAYERS.has(building)) {
                p.farms.forEach(sub => {
                    if (!sub.center) return;

                    state.context().beginPath();
                    state.context().translate(sub.center[0], sub.center[1]);
                    state.context().scale(0.8, 0.8);
                    state.context().translate(-sub.center[0], -sub.center[1]);
                    let pattern = state.context().createPattern(makeDiagonalPattern(sub), "repeat");
                    state.context().fillStyle = pattern;
                    drawPolygon(sub);
                    state.context().closePath();
                    state.context().fill();
                    state.context().setTransform(1, 0, 0, 1, 0, 0);
                    state.context().translate(state.transform.x, state.transform.y);
                    state.context().scale(state.transform.k, state.transform.k);
                });

            } else if (state.LAYERS.has(building) && site.type === 'castle') {
                state.context().translate(p.center[0], p.center[1]);
                state.context().scale(0.4, 0.4);
                state.context().translate(-p.center[0], -p.center[1]);
                state.context().fillStyle = color;
                state.context().lineWidth = 4;
                state.context().strokeStyle = 'black';
                drawPolygon(convert2Vertices(p.vertices));
                state.context().closePath();
                state.context().stroke();
                state.context().fill();
                state.context().setTransform(1, 0, 0, 1, 0, 0);
                state.context().translate(state.transform.x, state.transform.y);
                state.context().scale(state.transform.k, state.transform.k);

            } else if (state.LAYERS.has(building) && site.type === 'park') {
                state.context().translate(p.center[0], p.center[1]);
                state.context().scale(0.9, 0.9);
                state.context().translate(-p.center[0], -p.center[1]);
                state.context().fillStyle = color;
                state.context().lineWidth = 4;
                state.context().strokeStyle = 'black';
                drawPolygon(convert2Vertices(p.vertices));
                state.context().closePath();
                state.context().stroke();
                state.context().fill();
                state.context().setTransform(1, 0, 0, 1, 0, 0);
                state.context().translate(state.transform.x, state.transform.y);
                state.context().scale(state.transform.k, state.transform.k);
            }
            else {
                state.context().fillStyle = color;
                drawPolygon(convert2Vertices(p.vertices));
                state.context().closePath();
                state.context().fill();
            }
        });
        state.context().restore();
    }

    // draw single polygon
    function drawPolygon(vertices) {
        for (let i = 0; i < vertices.length; i++) {
            let vertex = vertices[i];

            state.context().moveTo(vertex[0], vertex[1]);
            for (let j = 0; j < vertices.length; j++) {
                let nextVertex = vertices[j];
                state.context().lineTo(nextVertex[0], nextVertex[1]);
            }
        }
    }

    // draw subPolygons(splitted polygon) of polygon that has subPolygons
    function drawSubPolygons() {
        state.context().save();
        state.graphics.polygons.forEach(p => {
            if (!p.subPolygons || p.subPolygons === 0) return;

            p.subPolygons.forEach(subPolygon => {
                if (!subPolygon || subPolygon === 0 || subPolygon.length === 0 || !subPolygon.center) return;
                // start drawing building
                state.context().beginPath();
                state.context().translate(subPolygon.center[0], subPolygon.center[1]);
                state.context().scale(0.8, 0.8);
                state.context().translate(-subPolygon.center[0], -subPolygon.center[1]);
                state.context().lineWidth = 1;
                state.context().strokeStyle = 'black';
                state.context().fillStyle = `rgb( ${subPolygon.color[0]}, ${subPolygon.color[1]}, ${subPolygon.color[2]} )`;
                // state.context().fillStyle = state.RANDOM_COLOR(Math.random());
                drawPolygon(subPolygon);
                state.context().closePath();
                state.context().stroke();
                state.context().fill();
                state.context().setTransform(1, 0, 0, 1, 0, 0);
                state.context().translate(state.transform.x, state.transform.y);
                state.context().scale(state.transform.k, state.transform.k);
            });
        });
        state.context().restore();
    }

    // draw buildings of subPolygons that of polygon
    function drawBuildings() {
        state.context().save();
        state.graphics.polygons.forEach(p => {
            if (!p.subPolygons || p.subPolygons === 0) return;

            p.subPolygons.forEach(subPoly => {
                if (!subPoly || subPoly === 0 || subPoly.length === 0 || !subPoly.center || !subPoly.buildings) return;

                subPoly.buildings.forEach(d => {
                    if (!d) return;

                    state.context().beginPath();
                    // state.context().translate(state.transform.x, state.transform.y);
                    // state.context().scale(state.transform.k, state.transform.k);
                    state.context().translate(d.x, d.y);
                    state.context().rotate(d.orientation);
                    state.context().translate(-(d.x), -(d.y));
                    state.context().lineWidth = 1;
                    if (d.random < .79) {
                        state.context().rect(d.x - d.width / 2, d.y - d.height / 2, d.width, d.height);
                        state.context().globalCompositeOperation = 'destination-over';
                        state.context().rect(d.x - d.offset.x, d.y - d.offset.y, d.width - d.offset.x, d.height - d.offset.y);
                    } else if (d.random > .8) {
                        state.context().rect(d.x - d.width / 2, d.y - d.height / 2, d.width, d.height);
                        state.context().globalCompositeOperation = 'destination-over';
                        state.context().arc(d.x + d.sign * d.offset.x, d.y + d.sign * d.offset.y, d.radius / 2, 0, 2 * Math.PI);
                    } else {
                        state.context().arc(d.x, d.y, d.radius, 0, 2 * Math.PI);
                    }

                    state.context().strokeStyle = "#000";
                    state.context().stroke();
                    state.context().globalCompositeOperation = 'source-over';
                    // state.context().fillStyle = "#98948b";
                    state.context().fillStyle = "#000";
                    state.context().fill();
                    state.context().setTransform(1, 0, 0, 1, 0, 0);
                    state.context().translate(state.transform.x, state.transform.y);
                    state.context().scale(state.transform.k, state.transform.k);
                });
            });
        });
        state.context().restore();
    }

    // draw circle following mouse
    function drawCursor(color) {
        if (!state.cursorCanvas) return;

        state.cursorContext().clearRect(0, 0, state.width(), state.height());
        state.cursorContext().beginPath();

        state.cursorContext().moveTo(state.pointer[0], state.pointer[1]);
        state.cursorContext().arc(state.pointer[0], state.pointer[1], state.radius, 0, 2 * Math.PI, false);
        state.cursorContext().arc(state.pointer[0], state.pointer[1], state.radius / 2, 0, 2 * Math.PI, false);

        state.cursorContext().moveTo(state.pointer[0], state.pointer[1]);
        state.cursorContext().lineTo(state.pointer[0] - state.radius, state.pointer[1]);

        state.cursorContext().moveTo(state.pointer[0], state.pointer[1] - state.radius);
        state.cursorContext().lineTo(state.pointer[0], state.pointer[1] + state.radius);

        state.cursorContext().lineWidth = 1.5;
        state.cursorContext().strokeStyle = color;
        state.cursorContext().stroke();
    }

    // draw dock
    function drawDock(bgColor, edgeColor, lineWidth) {
        if (!getAllTypes().get('harbor')) return;

        state.context().save();
        state.context().beginPath();
        state.graphics.sites
            .filter(s => s.type === 'harbor')
            .forEach(s => {
                let poly = state.graphics.polygons[s.index];

                convert2Edges(poly.edges).forEach(e => {
                    let left = e.left ? state.graphics.sites[e.left.index] : null;
                    let right = e.right ? state.graphics.sites[e.right.index] : null;
                    let waterSite = left.type === 'water' ? left : right;
                    let point = null;

                    if (waterSite.type === 'water') {
                        let midX = (e[0][0] + e[1][0]) / 2;
                        let midY = (e[0][1] + e[1][1]) / 2;
                        let d = distance(e[0], e[1]) / 2;
                        let dockDestination = getPerpendicularLineDestination(e[0][0], e[0][1], e[1][0], e[1][1], midX, midY, d);
                        let point1 = [dockDestination.x1, dockDestination.y1];
                        let point2 = [dockDestination.x2, dockDestination.y2];
                        let a = d3.polygonContains(convert2Vertices(state.graphics.polygons[waterSite.index].vertices), point1);

                        point = a ? point1 : point2;
                        let drawDistance = distance([midX, midY], point);
                        // condition for dock's length
                        if (drawDistance > d || drawDistance > 1 / state.N * 3500 || drawDistance < 1 / state.N * 1500) return;

                        state.context().moveTo(midX, midY);
                        state.context().lineTo(point[0], point[1]);
                        state.context().fillStyle = bgColor;
                        state.context().lineWidth = lineWidth;
                        state.context().strokeStyle = edgeColor;
                        state.context().fill();
                        state.context().stroke();
                    }
                });
            });
        state.context().restore();
    }

    // draw sites
    function drawSites(radius, color) {
        state.context().save();
        state.context().beginPath();

        for (let i = 0, n = state.graphics.polygons.length; i < n; i++) {
            let site = state.graphics.sites[state.graphics.polygons[i].site];

            state.context().moveTo(site[0] + radius, site[1]);
            state.context().arc(site[0], site[1], radius, 0, 2 * Math.PI, false);
            state.context().fillStyle = color;
            state.context().fill();
            state.context().strokeStyle = color;
            state.context().stroke();
            // state.context().font = '15px Monda sans-serif';
            // state.context().fillText(`${site['elevation'].toFixed(1)}`, site[0] - 10, site[1] - 10);
        }
        state.context().restore();
    }

    // draw edges
    function drawEdges(width, color) {
        state.context().save();

        for (let i = 0; i < state.graphics.edges.length; i++) {
            let edge = state.graphics.edges[i];
            if (edge !== null && edge !== undefined) {
                let start = state.vertices[edge[0].vertexIndex];
                let end = state.vertices[edge[1].vertexIndex];
                state.context().beginPath();
                state.context().moveTo(start[0], start[1]);
                state.context().lineTo(end[0], end[1]);
                state.context().lineWidth = width;
                state.context().strokeStyle = color;
                state.context().stroke();
            }
        }
        state.context().restore();
    }

    // draw triangles
    function drawTriangles() {
        state.context().save();
        state.context().beginPath();

        for (let i = 0, n = state.graphics.triangles.length; i < n; ++i) {
            let triangle = state.graphics.triangles[i];
            state.context().moveTo(triangle[0][0], triangle[0][1]);
            state.context().lineTo(triangle[1][0], triangle[1][1]);
            state.context().lineTo(triangle[2][0], triangle[2][1]);
            state.context().closePath();
            state.context().strokeStyle = `grey`;
            state.context().stroke();
        }
        state.context().restore();
    }

    // render background
    function renderBackground() {
        state.context().save();

        state.graphics.triangles.forEach(triangle => {
            const x1 = triangle[0][0],
                y1 = triangle[0][1],
                x2 = triangle[1][0],
                y2 = triangle[1][1],
                x3 = triangle[2][0],
                y3 = triangle[2][1],
                min_width = Math.min(x1, x2, x3),
                max_width = Math.max(x1, x2, x3),
                min_height = Math.min(y1, y2, y3),
                max_height = Math.max(y1, y2, y3);

            for (let x = min_width; x < max_width; x++) {
                for (let y = min_height; y < max_height; y++) {
                    let point = [x, y];
                    if (d3.polygonContains(triangle, point)) {
                        const weight = getBarycentricValue(x1, x2, x3, y1, y2, y3, point[0], point[1]);
                        const R = (triangle[0].color.R * weight.w1) + (triangle[1].color.R * weight.w2) + (triangle[2].color.R * weight.w3);
                        const G = (triangle[0].color.G * weight.w1) + (triangle[1].color.G * weight.w2) + (triangle[2].color.G * weight.w3);
                        const B = (triangle[0].color.B * weight.w1) + (triangle[1].color.B * weight.w2) + (triangle[2].color.B * weight.w3);

                        state.context().beginPath();
                        state.context().fillStyle = `rgb(${R}, ${G}, ${B})`;
                        state.context().fillRect(x, y, 1, 1);
                    }
                }
            }
        });
        state.context().restore();
    }

    /**
     * draw terrain contour lines based on given points
     * @param point
     * @param color
     * @param width
     */
    function drawContourLines(point, layer, color, width, isWall, isWaterLine) {
        state.context().save();

        if (!isWall) {
            state.context().translate(state.transform.x, state.transform.y);
            state.context().scale(state.transform.k, state.transform.k);
        }
        state.graphics.triangles.forEach(triangle => {
            let vertices = triangle.sort((a, b) => {
                if (a[layer] < b[layer]) {
                    return -1;
                } else if (a[layer] > b[layer]) {
                    return 1;
                } else {
                    return 0;
                }
            });

            if (point >= vertices[0][layer] && point <= vertices[2][layer]) {
                let e1, e2;
                if (point >= vertices[0][layer] && point <= vertices[1][layer]) {
                    e1 = [vertices[0], vertices[1]];
                    if (point >= vertices[0][layer] && point <= vertices[2][layer]) {
                        e2 = [vertices[0], vertices[2]];
                    } else {
                        e2 = [vertices[1], vertices[2]];
                    }
                } else {
                    e1 = [vertices[1], vertices[2]];
                    if (point >= vertices[1][layer] && point <= vertices[0][layer]) {
                        e2 = [vertices[0], vertices[1]];
                    } else {
                        e2 = [vertices[0], vertices[2]];
                    }
                }

                let pt1 = pointOnEdge(e1[0], e1[1], point, layer);
                let pt2 = pointOnEdge(e2[0], e2[1], point, layer);

                state.contourLines.clear();
                state.contourLines.push([pt1, pt2]);
                drawLine(pt1, pt2, width, color, isWaterLine);
            }
        });
        state.context().restore();
    }

    // draw a line from p1[0, 1] to p2[0, 1]
    function drawLine(p1, p2, width, color, isWaterLine) {
        if (state.waterline === 0) return;
        state.context().beginPath();
        state.context().fillStyle = color;
        state.context().lineWidth = width;
        state.context().lineCap = 'round';
        state.context().strokeStyle = color;
        if (!isWaterLine) {
            state.context().moveTo(p1[0], p1[1]);
            state.context().arc(p1[0], p1[1], 5, 0, 2 * Math.PI, false);
        }
        state.context().moveTo(p1[0], p1[1]);
        state.context().lineTo(p2[0], p2[1]);
        state.context().fill();
        state.context().stroke();
    }

    /*=====================================================================================================
                                             Additional Functions
    ======================================================================================================*/

    // get square of x
    function sqr(x) {
        return x * x;
    }

    // get distance of two vectors
    function distance(a, b) {
        return Math.sqrt(sqr(b[0] - a[0]) + sqr(b[1] - a[1]));
    }

    // get bounds of a specific polygon
    function bounds(polygon) {
        let xs = polygon.map(p => p[0]),
            ys = polygon.map(p => p[1]),
            minX = Math.min.apply(null, xs),
            maxX = Math.max.apply(null, xs),
            minY = Math.min.apply(null, ys),
            maxY = Math.max.apply(null, ys);

        return { width: maxX - minX, height: maxY - minY };
    }

    // get vertices from diagram.cell
    function getCellVertices(cell, diagram) {
        return cell.halfedges.map(i => cellHalfedgeStart(cell, diagram.edges[i]));
    }

    // relax sites, get average positions
    function relax(diagram) {
        return diagram.cells.map((cell, index) => getCellCentroid(cell, diagram, index));
    }

    // get startPoint of edge
    function cellHalfedgeStart(cell, edge) {
        return edge[+(edge.left !== cell.site)];
    }

    // get endPoint of edge
    function cellHalfedgeEnd(cell, edge) {
        return edge[+(edge.left === cell.site)];
    }

    // context menu event
    function menu() {
        // condition of closing
        if (!state.EDIT_MODES.has('district') && !state.EDIT_MODES.has('building')) {
            d3.select('.d3-context-menu').remove();
        }
        let x = state.transform.invertX(d3.event.layerX);
        let y = state.transform.invertY(d3.event.layerY);
        let site = findSite(x, y);
        let percentMap = getAllTypes();

        if (site.isBoundary) {
            return [{
                title: 'Current Type: ' + site.type,
            },
            {
                title: `water: ${percentMap.get('water') || 0} / ${state.N}`,
                action: function () {
                    site.type = 'water';
                    site['elevation'] = state.waterline / 2;
                    site['affluence'] = state.waterline / 2;
                    assignSubPolygons(site.index);
                    render();
                },
                disabled: site.type === 'water' ? true : false
            },
            {
                title: `farm: ${percentMap.get('farm') || 0} / ${state.N}`,
                action: function () {
                    site.type = 'farm';
                    assignSubPolygons(site.index);
                    render();
                },
                disabled: site.type === 'farm' ? true : false
            },
            {
                title: `empty: ${percentMap.get('empty') || 0} / ${state.N}`,
                action: function () {
                    site.type = 'empty';
                    site['elevation'] = 0.35;
                    site['affluence'] = 0;
                    assignSubPolygons(site.index);
                    render();
                },
                disabled: site.type === 'empty' ? true : false
            }];
        }

        return [{
            title: 'Current Type: ' + site.type,
        },
        {
            divider: true
        },
        {
            title: `rich: ${percentMap.get('rich') || 0} / ${state.N}`,
            action: function () {
                site.type = 'rich';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'rich' ? true : false
        },
        {
            title: `medium: ${percentMap.get('medium') || 0} / ${state.N}`,
            action: function () {
                site.type = 'medium';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'medium' ? true : false
        },
        {
            title: `poor: ${percentMap.get('poor') || 0} / ${state.N}`,
            action: function () {
                site.type = 'poor';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'poor' ? true : false
        },
        {
            title: `plaza: ${percentMap.get('plaza') || 0} / ${state.N}`,
            action: function () {
                site.type = 'plaza';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'plaza' ? true : false
        },
        {
            title: `park: ${percentMap.get('park') || 0} / ${state.N}`,
            action: function () {
                site.type = 'park';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'park' ? true : false
        },
        {
            title: `university: ${percentMap.get('university') || 0} / ${state.N}`,
            action: function () {
                site.type = 'university';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'university' ? true : false
        },
        // {
        //     title: `castle: ${percentMap.get('castle') || 0} / ${state.N}`,
        //     action: function () {
        //         site.type = 'castle';
        //         assignSubPolygons(site.index);
        //         render();
        //     },
        //     disabled: site.type === 'castle' ? true : false
        // },
        // {
        //     title: `military: ${percentMap.get('military') || 0} / ${state.N}`,
        //     action: function () {
        //         site.type = 'military';
        //         assignSubPolygons(site.index);
        //         render();
        //     },
        //     disabled: site.type === 'military' ? true : false
        // },
        {
            title: `religious: ${percentMap.get('religious') || 0} / ${state.N}`,
            action: function () {
                site.type = 'religious';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'religious' || Number(getAllTypes().get('religious')) > 2.5 / 100 * state.N ? true : false
        },
        {
            title: `farm: ${percentMap.get('farm') || 0} / ${state.N}`,
            action: function () {
                site.type = 'farm';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'farm' ? true : false
        },
        {
            title: `water: ${percentMap.get('water') || 0} / ${state.N}`,
            action: function () {
                site.type = 'water';
                site['elevation'] = state.waterline / 2;
                site['affluence'] = state.waterline / 2;
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'water' ? true : false
        },
        {
            title: `harbor: ${percentMap.get('harbor') || 0} / ${state.N}`,
            action: function () {
                site.type = 'harbor';
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'harbor' ? true : false
        },
        {
            title: `empty: ${percentMap.get('empty') || 0} / ${state.N}`,
            action: function () {
                site.type = 'empty';
                site['elevation'] = 0.35;
                site['affluence'] = 0;
                assignSubPolygons(site.index);
                render();
            },
            disabled: site.type === 'empty' ? true : false
        }];
    };

    /**
     * split 1 polygon into n sub-polygons
     * @param polygon: [vertex, vertex, ..., vertex]
     * @param n: number of sub-polygons
     * @param k: area ratio
     * @returns polygon [[0,1], ... [0,1]]
     */
    function splitPolygon(type, poly, n, k) {
        if (n == 0) return [];
        let subPoly = [poly];

        while (subPoly.length < n) {
            let p = subPoly.shift();
            let splitResult = splitPolyInto2(p, k);
            let poly1 = splitResult.poly1.poly.arrVector.map(p => [p.x, p.y]);
            let poly2 = splitResult.poly2.poly.arrVector.map(p => [p.x, p.y]);

            poly1.size = 10;
            poly2.size = 10;

            poly1.type = type;
            poly2.type = type;

            poly1.bounds = bounds(poly1);
            poly2.bounds = bounds(poly2);

            poly1.center = d3.polygonCentroid(poly1);
            poly2.center = d3.polygonCentroid(poly2);

            poly1.area = Math.abs(d3.polygonArea(poly1));
            poly2.area = Math.abs(d3.polygonArea(poly2));

            poly1.rotation = Math.random() > 0.5 ? Math.PI * 0.5 : Math.PI * 1;
            poly2.rotation = Math.random() > 0.5 ? Math.PI * 0.5 : Math.PI * 1;

            subPoly.push(poly1, poly2);
        }

        return subPoly;
    }

    // split 1 polygon into 2 sub-polygons
    // polygon [[0,1], ... [0,1]]
    function splitPolyInto2(polygon, k) {
        let poly = new Polygon();
        let area = Math.abs(d3.polygonArea(polygon)) * k;

        polygon.forEach(v => poly.push_back(new Vector(v[0], v[1])));

        return poly.split(area);
    }

    function findSite(x, y, radius) {
        var i = 0,
            n = state.graphics.sites.length,
            dx,
            dy,
            d2,
            site,
            closest;

        if (radius == null) radius = Infinity;
        else radius *= radius;

        for (i = 0; i < n; ++i) {
            site = state.graphics.sites[i];
            dx = x - site[0];
            dy = y - site[1];
            d2 = dx * dx + dy * dy;
            if (d2 < radius) closest = site, radius = d2;
        }

        return closest;
    }

    function findSites(x, y, radius) {
        let i = 0,
            n = state.graphics.sites.length,
            dx,
            dy,
            d2,
            site,
            closest = [];

        if (radius == null) return;
        else radius *= radius;

        for (i = 0; i < n; ++i) {
            site = state.graphics.sites[i];
            dx = x - site[0];
            dy = y - site[1];
            d2 = dx * dx + dy * dy;
            site.delta = 1 - d2 / radius;
            if (d2 < radius) closest.push(site);
        }

        return closest;
    }

    // https://codeplea.com/triangular-interpolation
    // https://koozdra.wordpress.com/2012/06/27/javascript-is-point-in-triangle
    function getBarycentricValue(x1, x2, x3, y1, y2, y3, px, py) {
        const w1 = ((y2 - y3) * (px - x3) + (x3 - x2) * (py - y3)) / ((y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3));
        const w2 = ((y3 - y1) * (px - x3) + (x1 - x3) * (py - y3)) / ((y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3));
        const w3 = 1 - w1 - w2;

        return { w1: w1, w2: w2, w3: w3 };
    }


    /**
     * get point position in the edge that consists of site1 and site2
     * @param site1: [0, 1]
     * @param site2: [0, 1]
     * @param point: Number
     * @returns {*[]}
     */
    function pointOnEdge(site1, site2, point, layer) {
        const lowest = site1[layer] < site2[layer] ? site1 : site2;
        const highest = lowest === site1 ? site2 : site1;
        const x = lowest[0] + (highest[0] - lowest[0]) * (point - lowest[layer]) / (highest[layer] - lowest[layer]);
        // const y = lowest[1] + (highest[1] - lowest[1]) * ( point - lowest['elevation'] ) / ( highest['elevation'] - lowest['elevation'] );
        const k = (lowest[1] - highest[1]) / (lowest[0] - highest[0]); // slope of line from site1 to site2
        const y = -k * (lowest[0] - x) + lowest[1];

        return [x, y];
    }

    /**
     * find adjacent sites on mouse position
     * @param site
     * @returns {Array}
     */
    function findAdjacentSites(index) {
        let sites = new Set();

        state.graphics.links.forEach(function (link) {
            if (link.source.index === index || link.target.index === index) {

                //get adjacent polygons
                state.graphics.polygons.forEach(function (p) {
                    if (state.graphics.sites[p.site].index === link.target.index || state.graphics.sites[p.site].index === link.source.index) {
                        sites.add(p.site);
                    }
                });
            }
        });

        return sites;
    }

    // combine different layers' color
    function combineColors(colors) {
        let r = 0, g = 0, b = 0, n = colors.length;

        colors.forEach(color => {
            r += Number(color[0]);
            g += Number(color[1]);
            b += Number(color[2]);
        });

        r /= n;
        g /= n;
        b /= n;

        return `rgb(${r}, ${g}, ${b})`;
    }

    // clear polygon's farms
    function clearSubPolygons(polygon) {
        if (!polygon.farms) return;

        polygon.farms.forEach(polygons => polygons.clear());
        polygon.farms = [];
    }

    // custom force
    function myForce() {
        var nodes,
            node,
            alpha,
            strength = constant(-12),
            strengths,
            distanceMin2 = 1,
            distanceMax2 = Infinity,
            theta2 = 0.81;

        function initialize() {
            if (!nodes) return;
            let i, n = nodes.length, node;
            strengths = new Array(n);
            // for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
            for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = -node.radius;
        }

        function force(_) {
            var i, n = nodes.length, tree = d3.quadtree(nodes, d3.x$1, d3.y$1).visitAfter(accumulate);
            for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
        }

        function accumulate(quad) {
            var strength = 0, q, c, weight = 0, x, y, i;

            // For internal nodes, accumulate forces from child quadrants.
            if (quad.length) {
                for (x = y = i = 0; i < 4; ++i) {
                    if ((q = quad[i]) && (c = Math.abs(q.value))) {
                        strength += q.value, weight += c, x += c * q.x, y += c * q.y;
                    }
                }
                quad.x = x / weight;
                quad.y = y / weight;
            }

            // For leaf nodes, accumulate forces from coincident quadrants.
            else {
                q = quad;
                q.x = q.data.x;
                q.y = q.data.y;
                do strength += strengths[q.data.index];
                while (q = q.next);
            }
            quad.value = strength;
        }

        function apply(quad, x1, _, x2) {
            if (!quad.value) return true;

            var x = quad.x - node.x,
                y = quad.y - node.y,
                w = x2 - x1,
                l = x * x + y * y;

            // Apply the Barnes-Hut approximation if possible.
            // Limit forces for very close nodes; randomize direction if coincident.
            if (w * w / theta2 < l) {
                if (l < distanceMax2) {
                    if (x === 0) x = jiggle(), l += x * x;
                    if (y === 0) y = jiggle(), l += y * y;
                    if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
                    node.vx += x * quad.value * alpha / l;
                    node.vy += y * quad.value * alpha / l;
                }
                return true;
            }

            // Otherwise, process points directly.
            else if (quad.length || l >= distanceMax2) return;

            // Limit forces for very close nodes; randomize direction if coincident.
            if (quad.data !== node || quad.next) {
                if (x === 0) x = jiggle(), l += x * x;
                if (y === 0) y = jiggle(), l += y * y;
                if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
            }

            do if (quad.data !== node) {
                w = strengths[quad.data.index] * alpha / l;
                node.vx += x * w;
                node.vy += y * w;
            } while (quad = quad.next);
        }

        force.iterations = function (_) {
            return arguments.length ? (iterations = +_, force) : iterations;
        };

        force.initialize = function (_) {
            n = (nodes = _).length;
            initialize();
        };

        force.distanceMin = function (_) {
            return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
        };

        force.distanceMax = function (_) {
            return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
        };

        force.strength = function (_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
        };

        return force;
    }

    // custom force of polygon collision
    // inspired from http://bl.ocks.org/larsenmtl/39a028da44db9e8daf14578cb354b5cb
    function forceCollidePolygon(polygon, radius) {
        var nodes, iterations = 1;

        // took from d3-force/src/collide.js
        if (typeof radius !== "function") radius = constant(radius == null ? 1 : +radius);

        function force() {
            for (let l = 0; l < iterations; l++) {
                for (let k = 0; k < nodes.length; k++) {
                    let node = nodes[k],
                        point = { x: node.x, y: node.y },
                        polyPoints = polygon,
                        center = { x: polygon.center[0], y: polygon.center[1] },
                        radius = node.radius,
                        inter = false,
                        vectors = [],
                        distances = [],
                        minDistance = 0,
                        indexOfNearestSegment = 0;

                    // we loop over polygon's edges to check collisions
                    for (let j = 0; j < polyPoints.length; j++) {
                        let n = (j + 1) < polyPoints.length ? (j + 1) : 0;
                        let segment1 = { x: polyPoints[j][0], y: polyPoints[j][1] };
                        let segment2 = { x: polyPoints[n][0], y: polyPoints[n][1] };
                        let vector = point2Segment(point, segment1, segment2);
                        let d = dist2Segment(point, vector);

                        vectors.push(vector);
                        distances.push(d);
                        minDistance = Math.min(...distances);
                        indexOfNearestSegment = distances.indexOf(minDistance);

                        // set min distance between the point and its nearest polygon segment
                        if (d < 8) {
                            let dvx = Math.abs(point.x - vector.x) / (d);
                            let dvy = Math.abs(point.y - vector.y) / (d);
                            node.vx += Math.sign(point.x - vector.x) * dvx;
                            node.vy += Math.sign(point.y - vector.y) * dvy;
                        }

                        // boundary detection
                        if (minDistance <= radius) {
                            let dvx = Math.abs(point.x - vectors[indexOfNearestSegment].x) / (minDistance);
                            let dvy = Math.abs(point.y - vectors[indexOfNearestSegment].y) / (minDistance);
                            node.vx = 0;
                            node.vy = 0;
                            node.vx += Math.sign(point.x - vectors[indexOfNearestSegment].x) * dvx;
                            node.vy += Math.sign(point.y - vectors[indexOfNearestSegment].y) * dvy;
                        }

                        // check whether point is intersecting with polygon bounds
                        inter = getLineIntersection(segment1.x, segment1.y, segment2.x, segment2.y, center.x, center.y, point.x, point.y);
                        if (inter) {
                            node.x = inter.x;
                            node.y = inter.y;
                            break;
                        }
                    }

                    // set point orientation
                    let nearestSegment = {
                        p1: polyPoints[indexOfNearestSegment] || polyPoints[0],
                        p2: polyPoints[indexOfNearestSegment + 1] || polyPoints[0]
                    };
                    node.orientation = Math.atan2(nearestSegment.p2[1] - nearestSegment.p1[1], nearestSegment.p2[0] - nearestSegment.p1[0]);
                }
            }
            return;
        }

        force.iterations = function (_) {
            return arguments.length ? (iterations = +_, force) : iterations;
        };

        force.initialize = function (_) {
            n = (nodes = _).length;
        };

        force.radius = function (_) {
            return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), force) : radius;
        };

        return force;
    }

    // source: http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect
    function getLineIntersection(p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y) {
        var s1_x, s1_y, s2_x, s2_y;
        s1_x = p1_x - p0_x;
        s1_y = p1_y - p0_y;
        s2_x = p3_x - p2_x;
        s2_y = p3_y - p2_y;
        var s, t;
        s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);
        t = (s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);

        if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
            var intX = p0_x + (t * s1_x);
            var intY = p0_y + (t * s1_y);
            return {
                x: intX,
                y: intY
            };
        }

        return false;
    }

    // took from d3-force/src/jiggle.js
    function jiggle() {
        // return (Math.random() - 0.5) * 1e-6;
        return 0;
    }

    // took from d3-force/src/constant.js
    function constant(x) {
        return function () {
            return x;
        };
    }

    function dist2(v, w) {
        return sqr(v.x - w.x) + sqr(v.y - w.y);
    }

    function point2Segment(p, v, w) {
        let l2 = dist2(v, w);

        if (l2 === 0) return dist2(p, v);

        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;

        if (t < 0) return v;
        if (t > 1) return w;

        return { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
    }

    function dist2Segment(point, vector) {
        return Math.sqrt(dist2(point, vector));
    }

    // convert indexes of vertex to vertices
    function convert2Vertices(indexes) {
        return indexes.map(i => state.vertices[i]);
    }

    // convert edge-index to edge
    function convert2Edges(indexes) {
        return indexes.map(i => state.graphics.edges[i]);
    }

    // get adjacent sites' type
    function getAdjacentTypes(index) {
        let adjacentTypesSet = new Set();
        findAdjacentSites(index).forEach(s => adjacentTypesSet.add(state.graphics.sites[s].type));

        return adjacentTypesSet;
    }

    /**
     * get all sites' type
     * @returns {Map<any, any>}
     */
    function getAllTypes() {
        let map = new Map();

        state.DISTRICT_TYPES.forEach(type => {
            state.graphics.sites.forEach(s => {
                if (type !== s.type) return;
                if (map.has(type)) {
                    map.set(type, map.get(type) + 1);
                } else {
                    map.set(type, 1);
                }
            });
        });

        return map;
    }

    /**
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param midX
     * @param midY
     * @param d
     * @returns {{x1: *, y1: *, x2: *, y2: *}}
     * @URL https://math.stackexchange.com/questions/306468/perpendicular-line-passing-through-the-midpoint-of-another-line
     */
    function getPerpendicularLineDestination(p1_x, p1_y, p2_x, p2_y, midX, midY, d) {
        let k1 = (p2_y - p1_y) / (p2_x - p1_x); // given segment slope
        let k2 = -1 / k1; // perpendicular line slope

        let x1 = midX + d / Math.sqrt(1 + sqr(k2));
        let y1 = midY + d * k2 / Math.sqrt(1 + sqr(k2));

        let x2 = midX - d / Math.sqrt(1 - sqr(k2));
        let y2 = midY - d * k2 / Math.sqrt(1 - sqr(k2));

        return { x1: x1, y1: y1, x2: x2, y2: y2 };
    }

    /*=====================================================================================================
                                        Export Functions
    ======================================================================================================*/
    return {
        state: state,
        graphics: state.graphics,
        newGraphics: newGraphics,
        drawContourLine: drawContourLine,
        checkboxOnChange: checkboxOnChange,
        incrementSliderOnChange: incrementSliderOnChange,
        waterLineSliderOnChange: waterLineSliderOnChange,
        elevationSwitchOnChange: elevationSwitchOnChange,
    };

    // initialize some global variables and renew graphics 
    function newGraphics(sites) {
        state.N = sites || 100;
        state.vertices.clear();
        state.isAltPressed = false;
        state.graphics.currentCastle = null;
        state.graphics = new Graphics();
        render();
    }

    // draw contour line
    function drawContourLine() {
        if (state.LAYERS.has(elevation)) {
            render();
            drawContourLines(state.waterline, 'elevation', 'blue', 4, false, true);
            drawContourLines(0.25, 'elevation', 'red', 4, false, false);
            drawContourLines(0.5, 'elevation', 'green', 4, false, false);
            drawContourLines(0.75, 'elevation', 'yellow', 4, false, false);
        }
    }

    function checkboxOnChange(type, layer, isChecked) {
        switch (layer) {
            case 'elevation': layerOnChange(type, isChecked, elevation, 'elevation'); break;
            case 'affluence': layerOnChange(type, isChecked, affluence, 'affluence'); break;
            case 'desirability': layerOnChange(type, isChecked, desirability, 'desirability'); break;
            case 'district': layerOnChange(type, isChecked, district, 'district'); break;
            case 'building': layerOnChange(type, isChecked, building, 'building'); break;
        }
    }

    // view + edit
    function layerOnChange(type, isChecked, viewLayer, editLayer) {
        if (type === 'view') {
            if (isChecked) {
                state.LAYERS.add(viewLayer);
            } else {
                if (state.LAYERS.size === 1) {
                    this.checked = true;
                    return;
                } else if (state.LAYERS.has(viewLayer)) {
                    state.LAYERS.delete(viewLayer);
                    state.EDIT_MODES.delete(editLayer);
                }
            }
        } else if (type === 'edit') {
            if (isChecked) {
                state.LAYERS.add(viewLayer);
                state.EDIT_MODES.add(editLayer);
            } else {
                state.EDIT_MODES.delete(editLayer);
            }
        } else {
            console.error('error: wrong layer type');
        }
        render();
    }

    // onChange event of increment slider
    function incrementSliderOnChange(value) {
        state.increment = value;
    }

    // onChange event of waterline slider
    function waterLineSliderOnChange(value) {
        state.waterline = value;
        onChangeWaterLine();
        drawContourLines(state.waterline, 'elevation', 'blue', 4, false, true);
    }

    // onChange event of elevation switch
    function elevationSwitchOnChange(isChecked) {
        state.isIncreasing = !isChecked;
    }
}